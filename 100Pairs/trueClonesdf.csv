clone1,clone2
"    public static void test(String args[]) {
        int trace;
        int bytes_read = 0;
        int last_contentLenght = 0;
        try {
            BufferedReader reader;
            URL url;
            url = new URL(args[0]);
            URLConnection istream = url.openConnection();
            last_contentLenght = istream.getContentLength();
            reader = new BufferedReader(new InputStreamReader(istream.getInputStream()));
            System.out.println(url.toString());
            String line;
            trace = t2pNewTrace();
            while ((line = reader.readLine()) != null) {
                bytes_read = bytes_read + line.length() + 1;
                t2pProcessLine(trace, line);
            }
            t2pHandleEventPairs(trace);
            t2pSort(trace, 0);
            t2pExportTrace(trace, new String(""pngtest2.png""), 1000, 700, (float) 0, (float) 33);
            t2pExportTrace(trace, new String(""pngtest3.png""), 1000, 700, (float) 2.3, (float) 2.44);
            System.out.println(""Press any key to contiune read from stream !!!"");
            System.out.println(t2pGetProcessName(trace, 0));
            System.in.read();
            istream = url.openConnection();
            if (last_contentLenght != istream.getContentLength()) {
                istream = url.openConnection();
                istream.setRequestProperty(""Range"", ""bytes="" + Integer.toString(bytes_read) + ""-"");
                System.out.println(Integer.toString(istream.getContentLength()));
                reader = new BufferedReader(new InputStreamReader(istream.getInputStream()));
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    t2pProcessLine(trace, line);
                }
            } else System.out.println(""File not changed !"");
            t2pDeleteTrace(trace);
        } catch (MalformedURLException e) {
            System.out.println(""MalformedURLException !!!"");
        } catch (IOException e) {
            System.out.println(""File not found "" + args[0]);
        }
        ;
    }
","    private static String loadUrlToString(String a_url) throws IOException {
        URL l_url1 = new URL(a_url);
        BufferedReader br = new BufferedReader(new InputStreamReader(l_url1.openStream()));
        String l_content = """";
        String l_ligne = null;
        l_content = br.readLine();
        while ((l_ligne = br.readLine()) != null) {
            l_content += AA.SL + l_ligne;
        }
        return l_content;
    }
"
"    public String kodetu(String testusoila) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance(""SHA"");
            md.update(testusoila.getBytes(""UTF-8""));
        } catch (NoSuchAlgorithmException e) {
            new MezuLeiho(""Ez da zifraketa algoritmoa aurkitu"", ""Ados"", ""Zifraketa Arazoa"", JOptionPane.ERROR_MESSAGE);
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            new MezuLeiho(""Errorea kodetzerakoan"", ""Ados"", ""Kodeketa Errorea"", JOptionPane.ERROR_MESSAGE);
            e.printStackTrace();
        }
        byte raw[] = md.digest();
        String hash = (new BASE64Encoder()).encode(raw);
        return hash;
    }
","    private StringBuffer encoder(String arg) {
        if (arg == null) {
            arg = """";
        }
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
            md5.update(arg.getBytes(SysConstant.charset));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return toHex(md5.digest());
    }
"
"    private String sha1(String s) {
        String encrypt = s;
        try {
            MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
            sha.update(s.getBytes());
            byte[] digest = sha.digest();
            final StringBuffer buffer = new StringBuffer();
            for (int i = 0; i < digest.length; ++i) {
                final byte b = digest[i];
                final int value = (b & 0x7F) + (b < 0 ? 128 : 0);
                buffer.append(value < 16 ? ""0"" : """");
                buffer.append(Integer.toHexString(value));
            }
            encrypt = buffer.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return encrypt;
    }
","    @SuppressWarnings(""unused"")
    private String getMD5(String value) {
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            return """";
        }
        md5.reset();
        md5.update(value.getBytes());
        byte[] messageDigest = md5.digest();
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++) {
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        }
        String hashedPassword = hexString.toString();
        return hashedPassword;
    }
"
"    private void storeFieldMap(WorkingContent c, Connection conn) throws SQLException {
        SQLDialect dialect = getDatabase().getSQLDialect();
        if (TRANSACTIONS_ENABLED) {
            conn.setAutoCommit(false);
        }
        try {
            Object thisKey = c.getPrimaryKey();
            deleteFieldContent(thisKey, conn);
            PreparedStatement ps = null;
            StructureItem nextItem;
            Map fieldMap = c.getFieldMap();
            String type;
            Object value, siKey;
            for (Iterator i = c.getStructure().getStructureItems().iterator(); i.hasNext(); ) {
                nextItem = (StructureItem) i.next();
                type = nextItem.getDataType().toUpperCase();
                siKey = nextItem.getPrimaryKey();
                value = fieldMap.get(nextItem.getName());
                try {
                    if (type.equals(StructureItem.DATE)) {
                        ps = conn.prepareStatement(sqlConstants.get(""INSERT_DATE_FIELD""));
                        ps.setObject(1, thisKey);
                        ps.setObject(2, siKey);
                        dialect.setDate(ps, 3, (Date) value);
                        ps.executeUpdate();
                    } else if (type.equals(StructureItem.INT) || type.equals(StructureItem.FLOAT) || type.equals(StructureItem.VARCHAR)) {
                        ps = conn.prepareStatement(sqlConstants.get(""INSERT_"" + type + ""_FIELD""));
                        ps.setObject(1, thisKey);
                        ps.setObject(2, siKey);
                        if (value != null) {
                            ps.setObject(3, value);
                        } else {
                            int sqlType = Types.INTEGER;
                            if (type.equals(StructureItem.FLOAT)) {
                                sqlType = Types.FLOAT;
                            } else if (type.equals(StructureItem.VARCHAR)) {
                                sqlType = Types.VARCHAR;
                            }
                            ps.setNull(3, sqlType);
                        }
                        ps.executeUpdate();
                    } else if (type.equals(StructureItem.TEXT)) {
                        setTextField(c, siKey, (String) value, conn);
                    }
                    if (ps != null) {
                        ps.close();
                        ps = null;
                    }
                } finally {
                    if (ps != null) ps.close();
                }
            }
            if (TRANSACTIONS_ENABLED) {
                conn.commit();
            }
        } catch (SQLException e) {
            if (TRANSACTIONS_ENABLED) {
                conn.rollback();
            }
            throw e;
        } finally {
            if (TRANSACTIONS_ENABLED) {
                conn.setAutoCommit(true);
            }
        }
    }
","    public void elimina(Pedido pe) throws errorSQL, errorConexionBD {
        System.out.println(""GestorPedido.elimina()"");
        int id = pe.getId();
        String sql;
        Statement stmt = null;
        try {
            gd.begin();
            sql = ""DELETE FROM pedido WHERE id="" + id;
            System.out.println(""Ejecutando: "" + sql);
            stmt = gd.getConexion().createStatement();
            stmt.executeUpdate(sql);
            System.out.println(""executeUpdate"");
            gd.commit();
            System.out.println(""commit"");
            stmt.close();
        } catch (SQLException e) {
            gd.rollback();
            throw new errorSQL(e.toString());
        } catch (errorConexionBD e) {
            System.err.println(""Error en GestorPedido.elimina(): "" + e);
        } catch (errorSQL e) {
            System.err.println(""Error en GestorPedido.elimina(): "" + e);
        }
    }
"
"    private static void main(String[] args) {
        try {
            File f = new File(""test.txt"");
            if (f.exists()) {
                throw new IOException(f + "" already exists.  I don't want to overwrite it."");
            }
            StraightStreamReader in;
            char[] cbuf = new char[0x1000];
            int read;
            int totRead;
            FileOutputStream out = new FileOutputStream(f);
            for (int i = 0x00; i < 0x100; i++) {
                out.write(i);
            }
            out.close();
            in = new StraightStreamReader(new FileInputStream(f));
            for (int i = 0x00; i < 0x100; i++) {
                read = in.read();
                if (read != i) {
                    System.err.println(""Error: "" + i + "" read as "" + read);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = in.read(cbuf);
            if (totRead != 0x100) {
                System.err.println(""Simple buffered read did not read the full amount: 0x"" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println(""Error: 0x"" + i + "" read as 0x"" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println(""Not enough read. Bytes read: "" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println(""Error: 0x"" + i + "" read as 0x"" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println(""Not enough read. Bytes read: "" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println(""Error: 0x"" + i + "" read as 0x"" + cbuf[i + 0x123]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println(""Not enough read. Bytes read: "" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println(""Error: 0x"" + i + "" read as 0x"" + cbuf[i + 0x123]);
                }
            }
            in.close();
            f.delete();
        } catch (IOException x) {
            System.err.println(x.getMessage());
        }
    }
","    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
"
"    public List<SuspectFileProcessingStatus> retrieve() throws Exception {
        BufferedOutputStream bos = null;
        try {
            String listFilePath = GeneralUtils.generateAbsolutePath(getDownloadDirectoryPath(), getListName(), ""/"");
            listFilePath = listFilePath.concat("".xml"");
            if (!new File(getDownloadDirectoryPath()).exists()) {
                FileUtils.forceMkdir(new File(getDownloadDirectoryPath()));
            }
            FileOutputStream listFileOutputStream = new FileOutputStream(listFilePath);
            bos = new BufferedOutputStream(listFileOutputStream);
            InputStream is = null;
            if (getUseProxy()) {
                is = URLUtils.getResponse(getUrl(), getUserName(), getPassword(), URLUtils.HTTP_GET_METHOD, getProxyHost(), getProxyPort());
                IOUtils.copyLarge(is, bos);
            } else {
                URLUtils.getResponse(getUrl(), getUserName(), getPassword(), bos, null);
            }
            bos.flush();
            bos.close();
            File listFile = new File(listFilePath);
            if (!listFile.exists()) {
                throw new IllegalStateException(""The list file did not get created"");
            }
            if (isLoggingInfo()) {
                logInfo(""Downloaded list file : "" + listFile);
            }
            List<SuspectFileProcessingStatus> sfpsList = new ArrayList<SuspectFileProcessingStatus>();
            String loadType = GeneralConstants.LOAD_TYPE_FULL;
            String feedType = GeneralConstants.EMPTY_TOKEN;
            String listName = getListName();
            String errorCode = """";
            String description = """";
            SuspectFileProcessingStatus sfps = getSuspectsLoaderService().storeFileIntoListIncomingDir(listFile, loadType, feedType, listName, errorCode, description);
            sfpsList.add(sfps);
            if (isLoggingInfo()) {
                logInfo(""Retrieved list file with SuspectFileProcessingStatus: "" + sfps);
            }
            return sfpsList;
        } finally {
            if (null != bos) {
                bos.close();
            }
        }
    }
","    void shutdown(final boolean unexpected) {
        if (unexpected) {
            log.warn(""S H U T D O W N   ---   received unexpected shutdown request."");
        } else {
            log.info(""S H U T D O W N   ---   start regular shutdown."");
        }
        if (this.uncaughtException != null) {
            log.warn(""Shutdown probably caused by the following Exception."", this.uncaughtException);
        }
        log.error(""check if we need the controler listener infrastructure"");
        if (this.dumpDataAtEnd) {
            new PopulationWriter(this.population, this.network).write(this.controlerIO.getOutputFilename(FILENAME_POPULATION));
            new NetworkWriter(this.network).write(this.controlerIO.getOutputFilename(FILENAME_NETWORK));
            new ConfigWriter(this.config).write(this.controlerIO.getOutputFilename(FILENAME_CONFIG));
            if (!unexpected && this.getConfig().vspExperimental().isWritingOutputEvents()) {
                File toFile = new File(this.controlerIO.getOutputFilename(""output_events.xml.gz""));
                File fromFile = new File(this.controlerIO.getIterationFilename(this.getLastIteration(), ""events.xml.gz""));
                IOUtils.copyFile(fromFile, toFile);
            }
        }
        if (unexpected) {
            log.info(""S H U T D O W N   ---   unexpected shutdown request completed."");
        } else {
            log.info(""S H U T D O W N   ---   regular shutdown completed."");
        }
        try {
            Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
        } catch (IllegalStateException e) {
            log.info(""Cannot remove shutdown hook. "" + e.getMessage());
        }
        this.shutdownHook = null;
        this.collectLogMessagesAppender = null;
        IOUtils.closeOutputDirLogging();
    }
"
"    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile(""diff"", "".htm"");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write(""<html><head><title>LOC Differences</title>\n"" + SCRIPT + ""</head>\n"" + ""<body bgcolor='#ffffff'>\n"" + ""<div onMouseOver=\""window.defaultStatus='Metrics'\"">\n"");
        if (addedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Added:</th>"" + ""<th>Add</th><th>Type</th></tr>"");
            out.write(addedTable.toString());
            out.write(""</table><br><br>"");
        }
        if (modifiedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Modified:</th>"" + ""<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>"" + ""<th>Total</th><th>Type</th></tr>"");
            out.write(modifiedTable.toString());
            out.write(""</table><br><br>"");
        }
        if (deletedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Deleted:</th>"" + ""<th>Del</th><th>Type</th></tr>"");
            out.write(deletedTable.toString());
            out.write(""</table><br><br>"");
        }
        out.write(""<table name=METRICS BORDER>\n"");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write(""<tr><td>Base:&nbsp;</td><td>"");
            out.write(Long.toString(base));
            out.write(""</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>"");
            out.write(Long.toString(deleted));
            out.write(""</td></tr>\n<tr><td>Modified:&nbsp;</td><td>"");
            out.write(Long.toString(modified));
            out.write(""</td></tr>\n<tr><td>Added:&nbsp;</td><td>"");
            out.write(Long.toString(added));
            out.write(""</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>"");
            out.write(Long.toString(added + modified));
            out.write(""</td></tr>\n"");
        }
        out.write(""<tr><td>Total:&nbsp;</td><td>"");
        out.write(Long.toString(total));
        out.write(""</td></tr>\n</table></div>"");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write(""</BODY></HTML>"".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
","    private void copyFileToDir(MyFile file, MyFile to, wlPanel panel) throws IOException {
        Utilities.print(""started copying "" + file.getAbsolutePath() + ""\n"");
        FileOutputStream fos = new FileOutputStream(new File(to.getAbsolutePath()));
        FileChannel foc = fos.getChannel();
        FileInputStream fis = new FileInputStream(new File(file.getAbsolutePath()));
        FileChannel fic = fis.getChannel();
        Date d1 = new Date();
        long amount = foc.transferFrom(fic, rest, fic.size() - rest);
        fic.close();
        foc.force(false);
        foc.close();
        Date d2 = new Date();
        long time = d2.getTime() - d1.getTime();
        double secs = time / 1000.0;
        double rate = amount / secs;
        frame.getStatusArea().append(secs + ""s "" + ""amount: "" + Utilities.humanReadable(amount) + "" rate: "" + Utilities.humanReadable(rate) + ""/s\n"", ""black"");
        panel.updateView();
    }
"
"    static void copyFile(File file, File file1) throws IOException {
        byte abyte0[] = new byte[512];
        FileInputStream fileinputstream = new FileInputStream(file);
        FileOutputStream fileoutputstream = new FileOutputStream(file1);
        int i;
        while ((i = fileinputstream.read(abyte0)) > 0) fileoutputstream.write(abyte0, 0, i);
        fileinputstream.close();
        fileoutputstream.close();
    }
","        public Void doInBackground() {
            setProgress(0);
            for (int i = 0; i < uploadFiles.size(); i++) {
                String filePath = uploadFiles.elementAt(i).getFilePath();
                String fileName = uploadFiles.elementAt(i).getFileName();
                String fileMsg = ""Uploading file "" + (i + 1) + ""/"" + uploadFiles.size() + ""\n"";
                this.publish(fileMsg);
                try {
                    File inFile = new File(filePath);
                    FileInputStream in = new FileInputStream(inFile);
                    byte[] inBytes = new byte[(int) chunkSize];
                    int count = 1;
                    int maxCount = (int) (inFile.length() / chunkSize);
                    if (inFile.length() % chunkSize > 0) {
                        maxCount++;
                    }
                    int readCount = 0;
                    readCount = in.read(inBytes);
                    while (readCount > 0) {
                        File splitFile = File.createTempFile(""upl"", null, null);
                        String splitName = splitFile.getPath();
                        FileOutputStream out = new FileOutputStream(splitFile);
                        out.write(inBytes, 0, readCount);
                        out.close();
                        boolean chunkFinal = (count == maxCount);
                        fileMsg = "" - Sending chunk "" + count + ""/"" + maxCount + "": "";
                        this.publish(fileMsg);
                        boolean uploadSuccess = false;
                        int uploadTries = 0;
                        while (!uploadSuccess && uploadTries <= 5) {
                            uploadTries++;
                            boolean uploadStatus = upload(splitName, fileName, count, chunkFinal);
                            if (uploadStatus) {
                                fileMsg = ""OK\n"";
                                this.publish(fileMsg);
                                uploadSuccess = true;
                            } else {
                                fileMsg = ""ERROR\n"";
                                this.publish(fileMsg);
                                uploadSuccess = false;
                            }
                        }
                        if (!uploadSuccess) {
                            fileMsg = ""There was an error uploading your files. Please let the pipeline administrator know about this problem. Cut and paste the messages in this box, and supply them.\n"";
                            this.publish(fileMsg);
                            errorFlag = true;
                            return null;
                        }
                        float thisProgress = (count * 100) / (maxCount);
                        float completeProgress = (i * (100 / uploadFiles.size()));
                        float totalProgress = completeProgress + (thisProgress / uploadFiles.size());
                        setProgress((int) totalProgress);
                        splitFile.delete();
                        readCount = in.read(inBytes);
                        count++;
                    }
                } catch (Exception e) {
                    this.publish(e.toString());
                }
            }
            return null;
        }
"
"    protected void update(String sql, Object[] args) {
        Connection conn = null;
        PreparedStatement pstmt = null;
        try {
            conn = JdbcUtils.getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(sql);
            this.setParameters(pstmt, args);
            pstmt.executeUpdate();
            conn.commit();
            conn.setAutoCommit(true);
        } catch (SQLException e) {
            try {
                if (conn != null) {
                    conn.rollback();
                    conn.setAutoCommit(true);
                }
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            throw new JdbcDaoException(e.getMessage(), e);
        } finally {
            JdbcUtils.free(pstmt, conn);
        }
    }
","    public boolean delete(int id) {
        boolean deletionOk = false;
        Connection conn = null;
        try {
            conn = db.getConnection();
            conn.setAutoCommit(false);
            String sql = ""DELETE FROM keyphrases WHERE website_id=?"";
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setInt(1, id);
            deletionOk = ps.executeUpdate() == 1;
            ps.close();
            sql = ""DELETE FROM websites WHERE id=?"";
            ps = conn.prepareStatement(sql);
            ps.setInt(1, id);
            boolean success = ps.executeUpdate() == 1;
            deletionOk = deletionOk && success;
            ps.close();
            conn.commit();
            conn.setAutoCommit(true);
        } catch (SQLException sqle) {
            try {
                conn.rollback();
                conn.setAutoCommit(true);
            } catch (SQLException sex) {
                throw new OsseoFailure(""SQL error: roll back failed. "", sex);
            }
            throw new OsseoFailure(""SQL error: cannot remove website with id "" + id + ""."", sqle);
        } finally {
            db.putConnection(conn);
        }
        return deletionOk;
    }
"
"    private static void copyFile(File inputFile, File outputFile) throws IOException {
        FileReader in = new FileReader(inputFile);
        FileWriter out = new FileWriter(outputFile);
        int c;
        while ((c = in.read()) != -1) out.write(c);
        in.close();
        out.close();
    }
","    public static void copy(FileInputStream source, FileOutputStream dest) throws IOException {
        FileChannel in = null, out = null;
        try {
            in = source.getChannel();
            out = dest.getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
"
"    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
","    public CopyAllDataToOtherFolderResponse CopyAllDataToOtherFolder(DPWSContext context, CopyAllDataToOtherFolder CopyAllDataInps) throws DPWSException {
        CopyAllDataToOtherFolderResponse cpyRp = new CopyAllDataToOtherFolderResponseImpl();
        int hany = 0;
        String errorMsg = null;
        try {
            if ((rootDir == null) || (rootDir.length() == (-1))) {
                errorMsg = LocalStorVerify.ISNT_ROOTFLD;
            } else {
                String sourceN = CopyAllDataInps.getSourceName();
                String targetN = CopyAllDataInps.getTargetName();
                if (LocalStorVerify.isValid(sourceN) && LocalStorVerify.isValid(targetN)) {
                    String srcDir = rootDir + File.separator + sourceN;
                    String trgDir = rootDir + File.separator + targetN;
                    if (LocalStorVerify.isLength(srcDir) && LocalStorVerify.isLength(trgDir)) {
                        for (File fs : new File(srcDir).listFiles()) {
                            File ft = new File(trgDir + '\\' + fs.getName());
                            FileChannel in = null, out = null;
                            try {
                                in = new FileInputStream(fs).getChannel();
                                out = new FileOutputStream(ft).getChannel();
                                long size = in.size();
                                MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
                                out.write(buf);
                            } finally {
                                if (in != null) in.close();
                                if (out != null) out.close();
                                hany++;
                            }
                        }
                    } else {
                        errorMsg = LocalStorVerify.FLD_TOOLNG;
                    }
                } else {
                    errorMsg = LocalStorVerify.ISNT_VALID;
                }
            }
        } catch (Throwable tr) {
            tr.printStackTrace();
            errorMsg = tr.getMessage();
            hany = (-1);
        }
        if (errorMsg != null) {
        }
        cpyRp.setNum(hany);
        return cpyRp;
    }
"
"    public static void executa(String arquivo, String filial, String ip) {
        String drive = arquivo.substring(0, 2);
        if (drive.indexOf("":"") == -1) drive = """";
        Properties p = Util.lerPropriedades(arquivo);
        String servidor = p.getProperty(""servidor"");
        String impressora = p.getProperty(""fila"");
        String arqRel = new String(drive + p.getProperty(""arquivo""));
        String copias = p.getProperty(""copias"");
        if (filial.equalsIgnoreCase(servidor)) {
            Socket s = null;
            int tentativas = 0;
            boolean conectado = false;
            while (!conectado) {
                try {
                    tentativas++;
                    System.out.println(""Tentando conectar "" + ip + "" ("" + tentativas + "")"");
                    s = new Socket(ip, 7000);
                    conectado = s.isConnected();
                } catch (ConnectException ce) {
                    System.err.println(ce.getMessage());
                    System.err.println(ce.getCause());
                } catch (UnknownHostException uhe) {
                    System.err.println(uhe.getMessage());
                } catch (IOException ioe) {
                    System.err.println(ioe.getMessage());
                }
            }
            FileInputStream in = null;
            BufferedOutputStream out = null;
            try {
                in = new FileInputStream(new File(arqRel));
                out = new BufferedOutputStream(new GZIPOutputStream(s.getOutputStream()));
            } catch (FileNotFoundException e3) {
                e3.printStackTrace();
            } catch (IOException e3) {
                e3.printStackTrace();
            }
            String arqtr = arqRel.substring(2);
            System.out.println(""Proximo arquivo: "" + arqRel + "" ->"" + arqtr);
            while (arqtr.length() < 30) arqtr += "" "";
            while (impressora.length() < 30) impressora += "" "";
            byte aux[] = new byte[30];
            byte cop[] = new byte[2];
            try {
                aux = arqtr.getBytes(""UTF8"");
                out.write(aux);
                aux = impressora.getBytes(""UTF8"");
                out.write(aux);
                cop = copias.getBytes(""UTF8"");
                out.write(cop);
                out.flush();
            } catch (UnsupportedEncodingException e2) {
                e2.printStackTrace();
            } catch (IOException e2) {
                e2.printStackTrace();
            }
            byte b[] = new byte[1024];
            int nBytes;
            try {
                while ((nBytes = in.read(b)) != -1) out.write(b, 0, nBytes);
                out.flush();
                out.close();
                in.close();
                s.close();
            } catch (IOException e1) {
                e1.printStackTrace();
            }
            System.out.println(""Arquivo "" + arqRel + "" foi transmitido. \n\n"");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            SimpleDateFormat dfArq = new SimpleDateFormat(""yyyy-MM-dd"");
            SimpleDateFormat dfLog = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
            String arqLog = ""log"" + filial + dfArq.format(new Date()) + "".txt"";
            PrintWriter pw = null;
            try {
                pw = new PrintWriter(new FileWriter(arqLog, true));
            } catch (IOException e) {
                e.printStackTrace();
            }
            pw.println(""Arquivo:  "" + arquivo + ""  "" + dfLog.format(new Date()));
            pw.flush();
            pw.close();
            File f = new File(arquivo);
            while (!f.delete()) {
                System.out.println(""Erro apagando "" + arquivo);
            }
        }
    }
","    public static synchronized void repartition(File[] sourceFiles, File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {
        if (!targetDirectory.exists()) {
            if (!targetDirectory.mkdirs()) throw new Exception(""Could not create directory "" + targetDirectory.getAbsolutePath());
        }
        File tmpFile = new File(targetDirectory, ""tmp.fasta"");
        FileOutputStream fos = new FileOutputStream(tmpFile);
        FileChannel fco = fos.getChannel();
        for (File file : sourceFiles) {
            FileInputStream fis = new FileInputStream(file);
            FileChannel fci = fis.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(64000);
            while (fci.read(buffer) > 0) {
                buffer.flip();
                fco.write(buffer);
                buffer.clear();
            }
            fci.close();
        }
        fco.close();
        FastaFile fastaFile = new FastaFile(tmpFile);
        fastaFile.split(targetDirectory, prefix, maxUnitBases, maxUnitEntries);
        tmpFile.delete();
    }
"
"    boolean copyFileStructure(File oldFile, File newFile) {
        if (oldFile == null || newFile == null) return false;
        File searchFile = newFile;
        do {
            if (oldFile.equals(searchFile)) return false;
            searchFile = searchFile.getParentFile();
        } while (searchFile != null);
        if (oldFile.isDirectory()) {
            if (progressDialog != null) {
                progressDialog.setDetailFile(oldFile, ProgressDialog.COPY);
            }
            if (simulateOnly) {
            } else {
                if (!newFile.mkdirs()) return false;
            }
            File[] subFiles = oldFile.listFiles();
            if (subFiles != null) {
                if (progressDialog != null) {
                    progressDialog.addWorkUnits(subFiles.length);
                }
                for (int i = 0; i < subFiles.length; i++) {
                    File oldSubFile = subFiles[i];
                    File newSubFile = new File(newFile, oldSubFile.getName());
                    if (!copyFileStructure(oldSubFile, newSubFile)) return false;
                    if (progressDialog != null) {
                        progressDialog.addProgress(1);
                        if (progressDialog.isCancelled()) return false;
                    }
                }
            }
        } else {
            if (simulateOnly) {
            } else {
                FileReader in = null;
                FileWriter out = null;
                try {
                    in = new FileReader(oldFile);
                    out = new FileWriter(newFile);
                    int count;
                    while ((count = in.read()) != -1) out.write(count);
                } catch (FileNotFoundException e) {
                    return false;
                } catch (IOException e) {
                    return false;
                } finally {
                    try {
                        if (in != null) in.close();
                        if (out != null) out.close();
                    } catch (IOException e) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
","    public void writeBack(File destinationFile, boolean makeCopy) throws IOException {
        if (makeCopy) {
            FileChannel sourceChannel = new java.io.FileInputStream(getFile()).getChannel();
            FileChannel destinationChannel = new java.io.FileOutputStream(destinationFile).getChannel();
            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
            sourceChannel.close();
            destinationChannel.close();
        } else {
            getFile().renameTo(destinationFile);
        }
        if (getExifTime() != null && getOriginalTime() != null && !getExifTime().equals(getOriginalTime())) {
            String adjustArgument = ""-ts"" + m_dfJhead.format(getExifTime());
            ProcessBuilder pb = new ProcessBuilder(m_tm.getJheadCommand(), adjustArgument, destinationFile.getAbsolutePath());
            pb.directory(destinationFile.getParentFile());
            System.out.println(pb.command().get(0) + "" "" + pb.command().get(1) + "" "" + pb.command().get(2));
            final Process p = pb.start();
            try {
                p.waitFor();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
"
"    public void extractProfile(String parentDir, String fileName, String profileName) {
        try {
            byte[] buf = new byte[1024];
            ZipInputStream zipinputstream = null;
            ZipEntry zipentry;
            if (createProfileDirectory(profileName, parentDir)) {
                debug(""the profile directory created .starting the profile extraction"");
                String profilePath = parentDir + File.separator + fileName;
                zipinputstream = new ZipInputStream(new FileInputStream(profilePath));
                zipentry = zipinputstream.getNextEntry();
                while (zipentry != null) {
                    String entryName = zipentry.getName();
                    int n;
                    FileOutputStream fileoutputstream;
                    File newFile = new File(entryName);
                    String directory = newFile.getParent();
                    if (directory == null) {
                        if (newFile.isDirectory()) break;
                    }
                    fileoutputstream = new FileOutputStream(parentDir + File.separator + profileName + File.separator + newFile.getName());
                    while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);
                    fileoutputstream.close();
                    zipinputstream.closeEntry();
                    zipentry = zipinputstream.getNextEntry();
                }
                zipinputstream.close();
                debug(""deleting the profile.zip file"");
                File newFile = new File(profilePath);
                if (newFile.delete()) {
                    debug(""the "" + ""["" + profilePath + ""]"" + "" deleted successfully"");
                } else {
                    debug(""profile"" + ""["" + profilePath + ""]"" + ""deletion fail"");
                    throw new IllegalArgumentException(""Error: deletion error!"");
                }
            } else {
                debug(""error creating the profile directory"");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
","    void copyFile(File inputFile, File outputFile) {
        try {
            FileReader in;
            in = new FileReader(inputFile);
            FileWriter out = new FileWriter(outputFile);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
"    public void run() {
        String s;
        s = """";
        try {
            URL url = new URL(""http://www.m-w.com/dictionary/"" + word);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String str;
            while (((str = in.readLine()) != null) && (!stopped)) {
                s = s + str;
            }
            in.close();
        } catch (MalformedURLException e) {
        } catch (IOException e) {
        }
        Pattern pattern = Pattern.compile(""Main Entry:.+?<br>(.+?)</td>"", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher matcher = pattern.matcher(s);
        java.io.StringWriter wr = new java.io.StringWriter();
        HTMLDocument doc = null;
        HTMLEditorKit kit = (HTMLEditorKit) editor.getEditorKit();
        try {
            doc = (HTMLDocument) editor.getDocument();
        } catch (Exception e) {
        }
        System.out.println(wr);
        editor.setContentType(""text/html"");
        if (matcher.find()) try {
            kit.insertHTML(doc, editor.getCaretPosition(), ""<HR>"" + matcher.group(1) + ""<HR>"", 0, 0, null);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } else try {
            kit.insertHTML(doc, editor.getCaretPosition(), ""<HR><FONT COLOR='RED'>NOT FOUND!!</FONT><HR>"", 0, 0, null);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        button.setEnabled(true);
    }
","    public static String[] readStats() throws Exception {
        URL url = null;
        BufferedReader reader = null;
        StringBuilder stringBuilder;
        try {
            url = new URL(""http://localhost:"" + port + webctx + ""/shared/js/libOO/health_check.sjs"");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod(""GET"");
            connection.setReadTimeout(10 * 1000);
            connection.connect();
            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            stringBuilder = new StringBuilder();
            String line = null;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line);
            }
            return stringBuilder.toString().split("","");
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
        }
    }
"
"    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println(""\n"" + src + "": not an ACRNEMA stream!"");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println(""\n"" + src + "": contains UIDs!"" + "" => probable already DICOM - do not convert"");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println(""\n"" + src + "": mismatch pixel data length!"" + "" => do not convert"");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, ""MONOCHROME2"");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
","    public static void unzip2(String strZipFile, String folder) throws IOException, ArchiveException {
        FileUtil.fileExists(strZipFile, true);
        final InputStream is = new FileInputStream(strZipFile);
        ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(""zip"", is);
        ZipArchiveEntry entry = null;
        OutputStream out = null;
        while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
            File zipPath = new File(folder);
            File destinationFilePath = new File(zipPath, entry.getName());
            destinationFilePath.getParentFile().mkdirs();
            if (entry.isDirectory()) {
                continue;
            } else {
                out = new FileOutputStream(new File(folder, entry.getName()));
                IOUtils.copy(in, out);
                out.close();
            }
        }
        in.close();
    }
"
"    private void preprocessObjects(GeoObject[] objects) throws IOException {
        System.out.println(""objects.length "" + objects.length);
        for (int i = 0; i < objects.length; i++) {
            String fileName = objects[i].getPath();
            int dotindex = fileName.lastIndexOf(""."");
            dotindex = dotindex < 0 ? 0 : dotindex;
            String tmp = dotindex < 1 ? fileName : fileName.substring(0, dotindex + 3) + ""w"";
            System.out.println(""i: "" + "" world filename "" + tmp);
            File worldFile = new File(tmp);
            if (worldFile.exists()) {
                BufferedReader worldFileReader = new BufferedReader(new InputStreamReader(new FileInputStream(worldFile)));
                if (staticDebugOn) debug(""b4nextline: "");
                line = worldFileReader.readLine();
                if (staticDebugOn) debug(""line: "" + line);
                if (line != null) {
                    line = worldFileReader.readLine();
                    if (staticDebugOn) debug(""line: "" + line);
                    tokenizer = new StringTokenizer(line, "" \n\t\r\"""", false);
                    objects[i].setLon(Double.valueOf(tokenizer.nextToken()).doubleValue());
                    line = worldFileReader.readLine();
                    if (staticDebugOn) debug(""line: "" + line);
                    tokenizer = new StringTokenizer(line, "" \n\t\r\"""", false);
                    objects[i].setLat(Double.valueOf(tokenizer.nextToken()).doubleValue());
                }
            }
            File file = new File(objects[i].getPath());
            if (file.exists()) {
                System.out.println(""object src file found "");
                int slashindex = fileName.lastIndexOf(java.io.File.separator);
                slashindex = slashindex < 0 ? 0 : slashindex;
                if (slashindex == 0) {
                    slashindex = fileName.lastIndexOf(""/"");
                    slashindex = slashindex < 0 ? 0 : slashindex;
                }
                tmp = slashindex < 1 ? fileName : fileName.substring(slashindex + 1, fileName.length());
                System.out.println(""filename "" + destinationDirectory + XPlat.fileSep + tmp);
                objects[i].setPath(tmp);
                file = new File(fileName);
                if (file.exists()) {
                    DataInputStream dataIn = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));
                    DataOutputStream dataOut = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(destinationDirectory + XPlat.fileSep + tmp)));
                    System.out.println(""copying to "" + destinationDirectory + XPlat.fileSep + tmp);
                    for (; ; ) {
                        try {
                            dataOut.writeShort(dataIn.readShort());
                        } catch (EOFException e) {
                            break;
                        } catch (IOException e) {
                            break;
                        }
                    }
                    dataOut.close();
                }
            }
        }
    }
","    private String transferWSDL(String usernameAndPassword) throws WiseConnectionException {
        String filePath = null;
        try {
            URL endpoint = new URL(wsdlURL);
            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();
            conn.setDoOutput(false);
            conn.setDoInput(true);
            conn.setUseCaches(false);
            conn.setRequestMethod(""GET"");
            conn.setRequestProperty(""Accept"", ""text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5"");
            conn.setRequestProperty(""Connection"", ""close"");
            if (this.password != null) {
                conn.setRequestProperty(""Authorization"", ""Basic "" + (new BASE64Encoder()).encode(usernameAndPassword.getBytes()));
            }
            InputStream is = null;
            if (conn.getResponseCode() == 200) {
                is = conn.getInputStream();
            } else {
                is = conn.getErrorStream();
                InputStreamReader isr = new InputStreamReader(is);
                StringWriter sw = new StringWriter();
                char[] buf = new char[200];
                int read = 0;
                while (read != -1) {
                    read = isr.read(buf);
                    sw.write(buf);
                }
                throw new WiseConnectionException(""Remote server's response is an error: "" + sw.toString());
            }
            File file = new File(tmpDir, new StringBuffer(""Wise"").append(IDGenerator.nextVal()).append("".xml"").toString());
            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));
            IOUtils.copyStream(fos, is);
            fos.close();
            is.close();
            filePath = file.getPath();
        } catch (WiseConnectionException wce) {
            throw wce;
        } catch (Exception e) {
            logger.error(""Failed to download wsdl from URL : "" + wsdlURL);
            throw new WiseConnectionException(""Wsdl download failed!"", e);
        }
        return filePath;
    }
"
"    public static String getMD5HashFromString(String message) {
        String hashword = null;
        try {
            MessageDigest md5 = MessageDigest.getInstance(""MD5"");
            md5.update(message.getBytes());
            BigInteger hash = new BigInteger(1, md5.digest());
            hashword = hash.toString(16);
        } catch (NoSuchAlgorithmException nsae) {
        }
        return hashword;
    }
","    public static byte[] gerarHash(String frase) {
        try {
            MessageDigest md = MessageDigest.getInstance(""SHA-1"");
            md.update(frase.getBytes());
            return md.digest();
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }
"
"    protected void doDownload(S3Bucket bucket, S3Object s3object) throws Exception {
        String key = s3object.getKey();
        key = trimPrefix(key);
        String[] path = key.split(""/"");
        String fileName = path[path.length - 1];
        String dirPath = """";
        for (int i = 0; i < path.length - 1; i++) {
            dirPath += path[i] + ""/"";
        }
        File outputDir = new File(downloadFileOutputDir + ""/"" + dirPath);
        if (outputDir.exists() == false) {
            outputDir.mkdirs();
        }
        File outputFile = new File(outputDir, fileName);
        long size = s3object.getContentLength();
        if (outputFile.exists() && outputFile.length() == size) {
            return;
        }
        long startTime = System.currentTimeMillis();
        log.info(""Download start.S3 file="" + s3object.getKey() + "" local file="" + outputFile.getAbsolutePath());
        FileOutputStream fout = null;
        S3Object dataObject = null;
        try {
            fout = new FileOutputStream(outputFile);
            dataObject = s3.getObject(bucket, s3object.getKey());
            InputStream is = dataObject.getDataInputStream();
            IOUtils.copyStream(is, fout);
            downloadedFileList.add(key);
            long downloadTime = System.currentTimeMillis() - startTime;
            log.info(""Download complete.Estimete time="" + downloadTime + ""ms "" + IOUtils.toBPSText(downloadTime, size));
        } catch (Exception e) {
            log.error(""Download fail. s3 file="" + key, e);
            outputFile.delete();
            throw e;
        } finally {
            IOUtils.closeNoException(fout);
            if (dataObject != null) {
                dataObject.closeDataInputStream();
            }
        }
    }
","    @Override
    protected ModelAndView handleRequestInternal(final HttpServletRequest request, final HttpServletResponse response) throws Exception {
        final String filename = ServletRequestUtils.getRequiredStringParameter(request, ""id"");
        final File file = new File(path, filename + "".html"");
        logger.debug(""Getting static content from: "" + file.getPath());
        final InputStream is = getServletContext().getResourceAsStream(file.getPath());
        OutputStream out = null;
        if (is != null) {
            try {
                out = response.getOutputStream();
                IOUtils.copy(is, out);
            } catch (IOException ioex) {
                logger.error(ioex);
            } finally {
                is.close();
                if (out != null) {
                    out.close();
                }
            }
        }
        return null;
    }
"
"    public static void copyFile(File dst, File src, boolean append) throws FileNotFoundException, IOException {
        dst.createNewFile();
        FileChannel in = new FileInputStream(src).getChannel();
        FileChannel out = new FileOutputStream(dst).getChannel();
        long startAt = 0;
        if (append) startAt = out.size();
        in.transferTo(startAt, in.size(), out);
        out.close();
        in.close();
    }
","    private static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
"
"    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
","    public static Checksum checksum(File file, Checksum checksum) throws IOException {
        if (file.isDirectory()) {
            throw new IllegalArgumentException(""Checksums can't be computed on directories"");
        }
        InputStream in = null;
        try {
            in = new CheckedInputStream(new FileInputStream(file), checksum);
            IOUtils.copy(in, new NullOutputStream());
        } finally {
            IOUtils.closeQuietly(in);
        }
        return checksum;
    }
"
"    public static void writeToFile(InputStream input, File file, ProgressListener listener, long length) {
        OutputStream output = null;
        try {
            output = new CountingOutputStream(new FileOutputStream(file), listener, length);
            IOUtils.copy(input, output);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            IOUtils.closeQuietly(input);
            IOUtils.closeQuietly(output);
        }
    }
","    public static void unzip2(String strZipFile, String folder) throws IOException, ArchiveException {
        FileUtil.fileExists(strZipFile, true);
        final InputStream is = new FileInputStream(strZipFile);
        ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(""zip"", is);
        ZipArchiveEntry entry = null;
        OutputStream out = null;
        while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
            File zipPath = new File(folder);
            File destinationFilePath = new File(zipPath, entry.getName());
            destinationFilePath.getParentFile().mkdirs();
            if (entry.isDirectory()) {
                continue;
            } else {
                out = new FileOutputStream(new File(folder, entry.getName()));
                IOUtils.copy(in, out);
                out.close();
            }
        }
        in.close();
    }
"
"    public String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance(""MD5"");
        byte[] md5hash = new byte[32];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        md5hash = md.digest();
        return convertToHex(md5hash);
    }
","    public static String generateHash(String value) {
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
            md5.reset();
            md5.update(value.getBytes());
        } catch (NoSuchAlgorithmException e) {
            log.error(""Could not find the requested hash method: "" + e.getMessage());
        }
        byte[] result = md5.digest();
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < result.length; i++) {
            hexString.append(Integer.toHexString(0xFF & result[i]));
        }
        return hexString.toString();
    }
"
"    public void testQueryForBinary() throws InvalidNodeTypeDefException, ParseException, Exception {
        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + ""images/photo.png"");
        assertNotNull(source);
        assertEquals(false, source.exists());
        OutputStream os = source.getOutputStream();
        assertNotNull(os);
        String content = ""foo is a bar"";
        os.write(content.getBytes());
        os.flush();
        os.close();
        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + ""images?/*[contains(local-name(), 'photo.png')]"");
        assertNotNull(qResult);
        Collection results = qResult.getChildren();
        assertEquals(1, results.size());
        Iterator it = results.iterator();
        JCRNodeSource rSrc = (JCRNodeSource) it.next();
        InputStream rSrcIn = rSrc.getInputStream();
        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();
        IOUtils.copy(rSrcIn, actualOut);
        rSrcIn.close();
        assertEquals(content, actualOut.toString());
        actualOut.close();
        rSrc.delete();
    }
","    private boolean enregistreToi() {
        PrintWriter lEcrivain;
        String laDest = ""./img_types/"" + sonImage;
        if (!new File(""./img_types"").exists()) {
            new File(""./img_types"").mkdirs();
        }
        try {
            FileChannel leFicSource = new FileInputStream(sonFichier).getChannel();
            FileChannel leFicDest = new FileOutputStream(laDest).getChannel();
            leFicSource.transferTo(0, leFicSource.size(), leFicDest);
            leFicSource.close();
            leFicDest.close();
            lEcrivain = new PrintWriter(new FileWriter(new File(""bundll/types.jay""), true));
            lEcrivain.println(sonNom);
            lEcrivain.println(sonImage);
            if (sonOptionRadio1.isSelected()) {
                lEcrivain.println(""0:?"");
            }
            if (sonOptionRadio2.isSelected()) {
                lEcrivain.println(""1:"" + JOptionPane.showInputDialog(null, ""Vous avez choisis de rendre ce terrain difficile � franchir.\nVeuillez en indiquer la raison."", ""Demande de pr�cision"", JOptionPane.INFORMATION_MESSAGE));
            }
            if (sonOptionRadio3.isSelected()) {
                lEcrivain.println(""2:?"");
            }
            lEcrivain.close();
            return true;
        } catch (Exception lException) {
            return false;
        }
    }
"
"    public static void main(String[] args) throws Exception {
        TripleDES tdes = new TripleDES();
        StreamBlockReader reader = new StreamBlockReader(new FileInputStream(""D:\\test.txt""));
        StreamBlockWriter writer = new StreamBlockWriter(new FileOutputStream(""D:\\testTDESENC.txt""));
        SingleKey key = new SingleKey(new Block(128), """");
        key = new SingleKey(new Block(""01011101110000101001100111001011101000001110111101001001101101101101100000011101100100110000101100001110000001111101001101001101""), """");
        Mode mode = new ECBTripleDESMode(tdes);
        tdes.encrypt(reader, writer, key, mode);
    }
","    private FileInputStream getPackageStream(String archivePath) throws IOException, PackageManagerException {
        final int lastSlashInName = filename.lastIndexOf(""/"");
        final String newFileName = filename.substring(lastSlashInName);
        File packageFile = new File((new StringBuilder()).append(archivePath).append(newFileName).toString());
        if (null != packageFile) return new FileInputStream(packageFile);
        if (null != packageURL) {
            final InputStream urlStream = new ConnectToServer(null).getInputStream(packageURL);
            packageFile = new File((new StringBuilder()).append(getName()).append("".deb"").toString());
            final OutputStream fileStream = new FileOutputStream(packageFile);
            final byte buffer[] = new byte[10240];
            for (int read = 0; (read = urlStream.read(buffer)) > 0; ) fileStream.write(buffer, 0, read);
            urlStream.close();
            fileStream.close();
            return new FileInputStream(packageFile);
        } else {
            final String errorMessage = PreferenceStoreHolder.getPreferenceStoreByName(""Screen"").getPreferenceAsString(""package.getPackageStream.packageURLIsNull"", ""No entry found for package.getPackageStream.packageURLIsNull"");
            if (pm != null) {
                pm.addWarning(errorMessage);
                logger.error(errorMessage);
            } else logger.error(errorMessage);
            throw new FileNotFoundException();
        }
    }
"
"    public void writeTo(File f) throws IOException {
        if (state != STATE_OK) throw new IllegalStateException(""Upload failed"");
        if (tempLocation == null) throw new IllegalStateException(""File already saved"");
        if (f.isDirectory()) f = new File(f, filename);
        FileInputStream fis = new FileInputStream(tempLocation);
        FileOutputStream fos = new FileOutputStream(f);
        byte[] buf = new byte[BUFFER_SIZE];
        try {
            int i = 0;
            while ((i = fis.read(buf)) != -1) fos.write(buf, 0, i);
        } finally {
            deleteTemporaryFile();
            fis.close();
            fos.close();
        }
    }
","    public static Boolean decompress(File source, File destination) {
        FileOutputStream outputStream;
        ZipInputStream inputStream;
        try {
            outputStream = null;
            inputStream = new ZipInputStream(new FileInputStream(source));
            int read;
            byte buffer[] = new byte[BUFFER_SIZE];
            ZipEntry zipEntry;
            while ((zipEntry = inputStream.getNextEntry()) != null) {
                if (zipEntry.isDirectory()) new File(destination, zipEntry.getName()).mkdirs(); else {
                    File fileEntry = new File(destination, zipEntry.getName());
                    fileEntry.getParentFile().mkdirs();
                    outputStream = new FileOutputStream(fileEntry);
                    while ((read = inputStream.read(buffer, 0, BUFFER_SIZE)) != -1) {
                        outputStream.write(buffer, 0, read);
                    }
                    outputStream.flush();
                    outputStream.close();
                }
            }
            inputStream.close();
        } catch (Exception oException) {
            return false;
        }
        return true;
    }
"
"    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {
        int k_blockSize = 1024;
        int byteCount;
        char[] buf = new char[k_blockSize];
        File ofp = new File(outFile);
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));
        zos.setMethod(ZipOutputStream.DEFLATED);
        OutputStreamWriter osw = new OutputStreamWriter(zos, ""ISO-8859-1"");
        BufferedWriter bw = new BufferedWriter(osw);
        ZipEntry zot = null;
        File ifp = new File(inFile);
        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));
        InputStreamReader isr = new InputStreamReader(zis, ""ISO-8859-1"");
        BufferedReader br = new BufferedReader(isr);
        ZipEntry zit = null;
        while ((zit = zis.getNextEntry()) != null) {
            if (zit.getName().equals(""content.xml"")) {
                continue;
            }
            zot = new ZipEntry(zit.getName());
            zos.putNextEntry(zot);
            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);
            bw.flush();
            zos.closeEntry();
        }
        zos.putNextEntry(new ZipEntry(""content.xml""));
        bw.flush();
        osw = new OutputStreamWriter(zos, ""UTF8"");
        bw = new BufferedWriter(osw);
        return bw;
    }
","    @Override
    protected ActionForward executeAction(ActionMapping mapping, ActionForm form, User user, HttpServletRequest request, HttpServletResponse response) throws Exception {
        long resourceId = ServletRequestUtils.getLongParameter(request, ""resourceId"", 0L);
        String attributeIdentifier = request.getParameter(""identifier"");
        if (resourceId != 0L && StringUtils.hasText(attributeIdentifier)) {
            try {
                BinaryAttribute binaryAttribute = resourceManager.readAttribute(resourceId, attributeIdentifier, user);
                response.addHeader(""Content-Disposition"", ""attachment; filename=\"""" + binaryAttribute.getName() + '""');
                String contentType = binaryAttribute.getContentType();
                if (contentType != null) {
                    if (""application/x-zip-compressed"".equalsIgnoreCase(contentType)) {
                        response.setContentType(""application/octet-stream"");
                    } else {
                        response.setContentType(contentType);
                    }
                } else {
                    response.setContentType(""application/octet-stream"");
                }
                IOUtils.copy(binaryAttribute.getInputStream(), response.getOutputStream());
                return null;
            } catch (DataRetrievalFailureException e) {
                addGlobalError(request, ""errors.notFound"");
            } catch (Exception e) {
                addGlobalError(request, e);
            }
        }
        return mapping.getInputForward();
    }
"
"    public void setBckImg(String newPath) {
        try {
            File inputFile = new File(getPath());
            File outputFile = new File(newPath);
            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {
                FileInputStream in = new FileInputStream(inputFile);
                FileOutputStream out = null;
                try {
                    out = new FileOutputStream(outputFile);
                } catch (FileNotFoundException ex1) {
                    ex1.printStackTrace();
                    JOptionPane.showMessageDialog(null, ex1.getMessage().substring(0, Math.min(ex1.getMessage().length(), drawPanel.MAX_DIALOG_MSG_SZ)) + ""-"" + getClass(), ""Set Bck Img"", JOptionPane.ERROR_MESSAGE);
                }
                int c;
                if (out != null) {
                    while ((c = in.read()) != -1) out.write(c);
                    out.close();
                }
                in.close();
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            LogHandler.log(ex.getMessage(), Level.INFO, ""LOG_MSG"", isLoggingEnabled());
            JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), drawPanel.MAX_DIALOG_MSG_SZ)) + ""-"" + getClass(), ""Set Bck Img"", JOptionPane.ERROR_MESSAGE);
        }
        setPath(newPath);
        bckImg = new ImageIcon(getPath());
    }
","    private static void prepare() {
        System.err.println(""PREPARING-----------------------------------------"");
        deleteHome();
        InputStream configStream = null;
        FileOutputStream tempStream = null;
        try {
            configStream = AllTests.class.getClassLoader().getResourceAsStream(""net/sf/archimede/test/resources/repository.xml"");
            new File(""temp"").mkdir();
            tempStream = new FileOutputStream(new File(""temp/repository.xml""));
            IOUtils.copy(configStream, tempStream);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (configStream != null) {
                    configStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (tempStream != null) {
                    try {
                        tempStream.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        String repositoryName = ""jackrabbit.repository"";
        Properties jndiProperties = new Properties();
        jndiProperties.put(""java.naming.provider.url"", ""http://sf.net/projects/archimede#1"");
        jndiProperties.put(""java.naming.factory.initial"", ""org.apache.jackrabbit.core.jndi.provider.DummyInitialContextFactory"");
        startupUtil = new StartupJcrUtil(REPOSITORY_HOME, ""temp/repository.xml"", repositoryName, jndiProperties);
        startupUtil.init();
    }
"
"    public static void copy(File src, File dst) {
        try {
            InputStream is = null;
            OutputStream os = null;
            try {
                is = new BufferedInputStream(new FileInputStream(src), BUFFER_SIZE);
                os = new BufferedOutputStream(new FileOutputStream(dst), BUFFER_SIZE);
                byte[] buffer = new byte[BUFFER_SIZE];
                int len = 0;
                while ((len = is.read(buffer)) > 0) os.write(buffer, 0, len);
            } finally {
                if (null != is) is.close();
                if (null != os) os.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
","    public static void copyFile(File destFile, File src) throws IOException {
        File destDir = destFile.getParentFile();
        File tempFile = new File(destFile + ""_tmp"");
        destDir.mkdirs();
        InputStream is = new FileInputStream(src);
        try {
            FileOutputStream os = new FileOutputStream(tempFile);
            try {
                byte[] buf = new byte[8192];
                int len;
                while ((len = is.read(buf)) > 0) os.write(buf, 0, len);
            } finally {
                os.close();
            }
        } finally {
            is.close();
        }
        destFile.delete();
        if (!tempFile.renameTo(destFile)) throw new IOException(""Unable to rename "" + tempFile + "" to "" + destFile);
    }
"
"    @Override
    public Collection<IAuthor> doImport() throws Exception {
        progress.initialize(2, ""Ściągam autorów amerykańskich"");
        String url = ""http://pl.wikipedia.org/wiki/Kategoria:Ameryka%C5%84scy_autorzy_fantastyki"";
        UrlResource resource = new UrlResource(url);
        InputStream urlInputStream = resource.getInputStream();
        StringWriter writer = new StringWriter();
        IOUtils.copy(urlInputStream, writer);
        progress.advance(""Parsuję autorów amerykańskich"");
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        String httpDoc = writer.toString();
        httpDoc = httpDoc.replaceFirst(""(?s)<!DOCTYPE.+?>\\n"", """");
        httpDoc = httpDoc.replaceAll(""(?s)<script.+?</script>"", """");
        httpDoc = ""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""no\"" ?>\n"" + httpDoc;
        ByteArrayInputStream byteInputStream = new ByteArrayInputStream(httpDoc.getBytes(""UTF-8""));
        Document doc = builder.parse(byteInputStream);
        ArrayList<String> authorNames = new ArrayList<String>();
        ArrayList<IAuthor> authors = new ArrayList<IAuthor>();
        XPathFactory xpathFactory = XPathFactory.newInstance();
        XPath xpath = xpathFactory.newXPath();
        NodeList list = (NodeList) xpath.evaluate(""//ul/li/div/div/a"", doc, XPathConstants.NODESET);
        for (int i = 0; i < list.getLength(); i++) {
            String name = list.item(i).getTextContent();
            if (StringUtils.isNotBlank(name)) {
                authorNames.add(name);
            }
        }
        list = (NodeList) xpath.evaluate(""//td/ul/li/a"", doc, XPathConstants.NODESET);
        for (int i = 0; i < list.getLength(); i++) {
            String name = list.item(i).getTextContent();
            if (StringUtils.isNotBlank(name)) {
                authorNames.add(name);
            }
        }
        for (String name : authorNames) {
            int idx = name.lastIndexOf(' ');
            String fname = name.substring(0, idx).trim();
            String lname = name.substring(idx + 1).trim();
            authors.add(new Author(fname, lname));
        }
        progress.advance(""Wykonano"");
        return authors;
    }
","    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
"
"    @Override
    public String toString() {
        if (byteArrayOutputStream == null) return ""<Unparsed binary data: Content-Type="" + getHeader(""Content-Type"") + "" >"";
        String charsetName = getCharsetName();
        if (charsetName == null) charsetName = ""ISO-8859-1"";
        try {
            if (unzip) {
                GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));
                ByteArrayOutputStream unzippedResult = new ByteArrayOutputStream();
                IOUtils.copy(gzipInputStream, unzippedResult);
                return unzippedResult.toString(charsetName);
            } else {
                return byteArrayOutputStream.toString(charsetName);
            }
        } catch (UnsupportedEncodingException e) {
            throw new OutputException(e);
        } catch (IOException e) {
            throw new OutputException(e);
        }
    }
","    public void uploadFile(String filename) throws RQLException {
        checkFtpClient();
        OutputStream out = null;
        try {
            out = ftpClient.storeFileStream(filename);
            IOUtils.copy(new FileReader(filename), out);
            out.close();
            ftpClient.completePendingCommand();
        } catch (IOException ex) {
            throw new RQLException(""Upload of local file with name "" + filename + "" via FTP to server "" + server + "" failed."", ex);
        }
    }
"
"    public static void copyFile(File in, File out, boolean append) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out, append).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
","    @Test
    public void testTrainingDefault() throws IOException {
        File temp = File.createTempFile(""fannj_"", "".tmp"");
        temp.deleteOnExit();
        IOUtils.copy(this.getClass().getResourceAsStream(""xor.data""), new FileOutputStream(temp));
        List<Layer> layers = new ArrayList<Layer>();
        layers.add(Layer.create(2));
        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));
        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));
        Fann fann = new Fann(layers);
        Trainer trainer = new Trainer(fann);
        float desiredError = .001f;
        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);
        assertTrue("""" + mse, mse <= desiredError);
    }
"
"    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
","    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    private static void copy(String from_name, String to_name) throws IOException {
        File from_file = new File(from_name);
        File to_file = new File(to_name);
        if (!from_file.exists()) abort(""�������� ���� �� ���������"" + from_file);
        if (!from_file.isFile()) abort(""���������� ����������� ��������"" + from_file);
        if (!from_file.canRead()) abort(""�������� ���� ���������� ��� ������"" + from_file);
        if (from_file.isDirectory()) to_file = new File(to_file, from_file.getName());
        if (to_file.exists()) {
            if (!to_file.canWrite()) abort(""�������� ���� ���������� ��� ������"" + to_file);
            System.out.println(""������������ ������� ����?"" + to_file.getName() + ""?(Y/N):"");
            System.out.flush();
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            String response = in.readLine();
            if (!response.equals(""Y"") && !response.equals(""y"")) abort(""������������ ���� �� ��� �����������"");
        } else {
            String parent = to_file.getParent();
            if (parent == null) parent = System.getProperty(""user.dir"");
            File dir = new File(parent);
            if (!dir.exists()) abort(""������� ���������� �� ���������"" + parent);
            if (!dir.isFile()) abort(""�� �������� ���������"" + parent);
            if (!dir.canWrite()) abort(""������ �� ������"" + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(from_file);
            to = new FileOutputStream(to_file);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
","    public static void downloadJars(IProject project, String repositoryUrl, String jarDirectory, String[] jars) {
        try {
            File tmpFile = null;
            for (String jar : jars) {
                try {
                    tmpFile = File.createTempFile(""tmpPlugin_"", "".zip"");
                    URL url = new URL(repositoryUrl + jarDirectory + jar);
                    String destFilename = new File(url.getFile()).getName();
                    File destFile = new File(project.getLocation().append(""lib"").append(jarDirectory).toFile(), destFilename);
                    InputStream inputStream = null;
                    FileOutputStream outputStream = null;
                    try {
                        URLConnection urlConnection = url.openConnection();
                        inputStream = urlConnection.getInputStream();
                        outputStream = new FileOutputStream(tmpFile);
                        IOUtils.copy(inputStream, outputStream);
                    } finally {
                        if (outputStream != null) {
                            outputStream.close();
                        }
                        if (inputStream != null) {
                            inputStream.close();
                        }
                    }
                    FileUtils.copyFile(tmpFile, destFile);
                } finally {
                    if (tmpFile != null) {
                        tmpFile.delete();
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
"
"    protected String getLibJSCode() throws IOException {
        if (cachedLibJSCode == null) {
            InputStream is = getClass().getResourceAsStream(JS_LIB_FILE);
            StringWriter output = new StringWriter();
            IOUtils.copy(is, output);
            cachedLibJSCode = output.toString();
        }
        return cachedLibJSCode;
    }
","    private static void copyFile(File in, File out) throws Exception {
        final FileInputStream input = new FileInputStream(in);
        try {
            final FileOutputStream output = new FileOutputStream(out);
            try {
                final byte[] buf = new byte[4096];
                int readBytes = 0;
                while ((readBytes = input.read(buf)) != -1) {
                    output.write(buf, 0, readBytes);
                }
            } finally {
                output.close();
            }
        } finally {
            input.close();
        }
    }
"
"    public String md5(String password) {
        MessageDigest m = null;
        try {
            m = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException ex) {
        }
        m.update(password.getBytes(), 0, password.length());
        return new BigInteger(1, m.digest()).toString(16);
    }
","    public final String encrypt(final String plaintext, final String salt) {
        if (plaintext == null) {
            throw new NullPointerException();
        }
        if (salt == null) {
            throw new NullPointerException();
        }
        try {
            final MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update((plaintext + salt).getBytes(""UTF-8""));
            return new BASE64Encoder().encode(md.digest());
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionException(e);
        } catch (UnsupportedEncodingException e) {
            throw new EncryptionException(e);
        }
    }
"
"    public static void copyFile(File inputFile, File outputFile) throws IOException {
        FileChannel inChannel = null;
        FileChannel outChannel = null;
        try {
            inChannel = new FileInputStream(inputFile).getChannel();
            outChannel = new FileOutputStream(outputFile).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            try {
                if (inChannel != null) {
                    inChannel.close();
                }
                if (outChannel != null) {
                    outChannel.close();
                }
            } catch (IOException e) {
                throw e;
            }
        }
    }
","    void copyFile(File src, File dst) throws IOException {
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst);
        byte[] buf = new byte[1024];
        int len;
        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
        in.close();
        out.close();
    }
"
"    public void testStorageStringWriter() throws Exception {
        TranslationResponseInMemory r = new TranslationResponseInMemory(2048, ""UTF-8"");
        {
            Writer w = r.getWriter();
            w.write(""This is an example"");
            w.write("" and another one."");
            w.flush();
            assertEquals(""This is an example and another one."", r.getText());
        }
        {
            InputStream input = r.getInputStream();
            StringWriter writer = new StringWriter();
            try {
                IOUtils.copy(input, writer, ""UTF-8"");
            } finally {
                input.close();
                writer.close();
            }
            assertEquals(""This is an example and another one."", writer.toString());
        }
        try {
            r.getOutputStream();
            fail(""Is not allowed as you already called getWriter()."");
        } catch (IOException e) {
        }
        {
            Writer output = r.getWriter();
            output.write("" and another line"");
            output.write("" and write some more"");
            assertEquals(""This is an example and another one. and another line and write some more"", r.getText());
        }
        {
            r.addText("" and some more."");
            assertEquals(""This is an example and another one. and another line and write some more and some more."", r.getText());
        }
        r.setEndState(ResponseStateOk.getInstance());
        assertEquals(ResponseStateOk.getInstance(), r.getEndState());
        try {
            r.getWriter();
            fail(""Previous line should throw IOException as result closed."");
        } catch (IOException e) {
        }
    }
","    private void zipFiles(File file, File[] fa) throws Exception {
        File f = new File(file, ALL_FILES_NAME);
        if (f.exists()) {
            f.delete();
            f = new File(file, ALL_FILES_NAME);
        }
        ZipOutputStream zoutstrm = new ZipOutputStream(new FileOutputStream(f));
        for (int i = 0; i < fa.length; i++) {
            ZipEntry zipEntry = new ZipEntry(fa[i].getName());
            zoutstrm.putNextEntry(zipEntry);
            FileInputStream fr = new FileInputStream(fa[i]);
            byte[] buffer = new byte[1024];
            int readCount = 0;
            while ((readCount = fr.read(buffer)) > 0) {
                zoutstrm.write(buffer, 0, readCount);
            }
            fr.close();
            zoutstrm.closeEntry();
        }
        zoutstrm.close();
        log(""created zip file: "" + file.getName() + ""/"" + ALL_FILES_NAME);
    }
"
"    protected List<Datastream> getDatastreams(final DepositCollection pDeposit) throws IOException, SWORDException {
        List<Datastream> tDatastreams = new ArrayList<Datastream>();
        LOG.debug(""copying file"");
        String tZipTempFileName = super.getTempDir() + ""uploaded-file.tmp"";
        IOUtils.copy(pDeposit.getFile(), new FileOutputStream(tZipTempFileName));
        Datastream tDatastream = new LocalDatastream(super.getGenericFileName(pDeposit), this.getContentType(), tZipTempFileName);
        tDatastreams.add(tDatastream);
        tDatastreams.addAll(_zipFile.getFiles(tZipTempFileName));
        return tDatastreams;
    }
","    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    public void addEntry(InputStream jis, JarEntry entry) throws IOException, URISyntaxException {
        File target = new File(this.target.getPath() + entry.getName()).getAbsoluteFile();
        if (!target.exists()) {
            target.createNewFile();
        }
        if ((new File(this.source.toURI())).isDirectory()) {
            File sourceEntry = new File(this.source.getPath() + entry.getName());
            FileInputStream fis = new FileInputStream(sourceEntry);
            byte[] classBytes = new byte[fis.available()];
            fis.read(classBytes);
            (new FileOutputStream(target)).write(classBytes);
        } else {
            readwriteStreams(jis, (new FileOutputStream(target)));
        }
    }
","    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
"
"    public static boolean copyMerge(FileSystem srcFS, Path srcDir, FileSystem dstFS, Path dstFile, boolean deleteSource, Configuration conf, String addString) throws IOException {
        dstFile = checkDest(srcDir.getName(), dstFS, dstFile, false);
        if (!srcFS.getFileStatus(srcDir).isDir()) return false;
        OutputStream out = dstFS.create(dstFile);
        try {
            FileStatus contents[] = srcFS.listStatus(srcDir);
            for (int i = 0; i < contents.length; i++) {
                if (!contents[i].isDir()) {
                    InputStream in = srcFS.open(contents[i].getPath());
                    try {
                        IOUtils.copyBytes(in, out, conf, false);
                        if (addString != null) out.write(addString.getBytes(""UTF-8""));
                    } finally {
                        in.close();
                    }
                }
            }
        } finally {
            out.close();
        }
        if (deleteSource) {
            return srcFS.delete(srcDir, true);
        } else {
            return true;
        }
    }
","    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {
        int k_blockSize = 1024;
        int byteCount;
        char[] buf = new char[k_blockSize];
        File ofp = new File(outFile);
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));
        zos.setMethod(ZipOutputStream.DEFLATED);
        OutputStreamWriter osw = new OutputStreamWriter(zos, ""ISO-8859-1"");
        BufferedWriter bw = new BufferedWriter(osw);
        ZipEntry zot = null;
        File ifp = new File(inFile);
        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));
        InputStreamReader isr = new InputStreamReader(zis, ""ISO-8859-1"");
        BufferedReader br = new BufferedReader(isr);
        ZipEntry zit = null;
        while ((zit = zis.getNextEntry()) != null) {
            if (zit.getName().equals(""content.xml"")) {
                continue;
            }
            zot = new ZipEntry(zit.getName());
            zos.putNextEntry(zot);
            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);
            bw.flush();
            zos.closeEntry();
        }
        zos.putNextEntry(new ZipEntry(""content.xml""));
        bw.flush();
        osw = new OutputStreamWriter(zos, ""UTF8"");
        bw = new BufferedWriter(osw);
        return bw;
    }
"
"    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
","    private void copyFile(String fileName, String messageID, boolean isError) {
        try {
            File inputFile = new File(fileName);
            File outputFile = null;
            if (isError) {
                outputFile = new File(provider.getErrorDataLocation(folderName) + messageID + "".xml"");
            } else {
                outputFile = new File(provider.getDataProcessedLocation(folderName) + messageID + "".xml"");
            }
            FileReader in = new FileReader(inputFile);
            FileWriter out = new FileWriter(outputFile);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (Exception e) {
        }
    }
"
"    @Test
    public void testWriteAndReadBigger() throws Exception {
        JCFSFileServer server = new JCFSFileServer(defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);
        JCFS.configureDiscovery(defaultUdpAddress, defaultUdpPort);
        try {
            server.start();
            RFile file = new RFile(""testreadwrite.txt"");
            RFileOutputStream out = new RFileOutputStream(file);
            String body = """";
            int size = 50 * 1024;
            for (int i = 0; i < size; i++) {
                body = body + ""a"";
            }
            out.write(body.getBytes(""utf-8""));
            out.close();
            File expected = new File(dir, ""testreadwrite.txt"");
            assertTrue(expected.isFile());
            assertEquals(body.length(), expected.length());
            RFileInputStream in = new RFileInputStream(file);
            byte[] buffer = new byte[body.length()];
            int readCount = in.read(buffer);
            in.close();
            assertEquals(body.length(), readCount);
            String resultRead = new String(buffer, ""utf-8"");
            assertEquals(body, resultRead);
        } finally {
            server.stop();
        }
    }
","    public DialogSongList(JFrame frame) {
        super(frame, ""Menu_SongList"", ""songList"");
        setMinimumSize(new Dimension(400, 200));
        JPanel panel, spanel;
        Container contentPane;
        (contentPane = getContentPane()).add(songSelector = new SongSelector(configKey, null, true));
        songSelector.setSelectionAction(new Runnable() {

            public void run() {
                final Item<URL, MidiFileInfo> item = songSelector.getSelectedInfo();
                if (item != null) {
                    try {
                        selection = new File(item.getKey().toURI());
                        author.setEnabled(true);
                        title.setEnabled(true);
                        difficulty.setEnabled(true);
                        save.setEnabled(true);
                        final MidiFileInfo info = item.getValue();
                        author.setText(info.getAuthor());
                        title.setText(info.getTitle());
                        Util.selectKey(difficulty, info.getDifficulty());
                        return;
                    } catch (Exception e) {
                    }
                }
                selection = null;
                author.setEnabled(false);
                title.setEnabled(false);
                difficulty.setEnabled(false);
                save.setEnabled(false);
            }
        });
        contentPane.add(panel = new JPanel(), BorderLayout.SOUTH);
        panel.setLayout(new BorderLayout());
        JScrollPane scrollPane;
        panel.add(scrollPane = new JScrollPane(spanel = new JPanel()), BorderLayout.NORTH);
        scrollPane.setPreferredSize(new Dimension(0, 60));
        Util.addLabeledComponent(spanel, ""Lbl_Author"", author = new JTextField(10));
        Util.addLabeledComponent(spanel, ""Lbl_Title"", title = new JTextField(14));
        Util.addLabeledComponent(spanel, ""Lbl_Difficulty"", difficulty = new JComboBox());
        difficulty.addItem(new Item<Byte, String>((byte) -1, """"));
        for (Map.Entry<Byte, String> entry : SongSelector.DIFFICULTIES.entrySet()) {
            final String value = entry.getValue();
            difficulty.addItem(new Item<Byte, String>(entry.getKey(), Util.getMsg(value, value), value));
        }
        spanel.add(save = new JButton());
        Util.updateButtonText(save, ""Save"");
        save.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                final File selected = MidiSong.setMidiFileInfo(selection, author.getText(), title.getText(), getAsByte(difficulty));
                SongSelector.refresh();
                try {
                    songSelector.setSelected(selected == null ? null : selected.toURI().toURL());
                } catch (MalformedURLException ex) {
                }
            }
        });
        author.setEnabled(false);
        title.setEnabled(false);
        difficulty.setEnabled(false);
        save.setEnabled(false);
        JButton button;
        panel.add(spanel = new JPanel(), BorderLayout.WEST);
        spanel.add(button = new JButton());
        Util.updateButtonText(button, ""Import"");
        button.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                final File inputFile = KeyboardHero.midiFile();
                try {
                    if (inputFile == null) return;
                    final File dir = (new File(Util.DATA_FOLDER + MidiSong.MIDI_FILES_DIR));
                    if (dir.exists()) {
                        if (!dir.isDirectory()) {
                            Util.error(Util.getMsg(""Err_MidiFilesDirNotDirectory""), dir.getParent());
                            return;
                        }
                    } else if (!dir.mkdirs()) {
                        Util.error(Util.getMsg(""Err_CouldntMkDir""), dir.getParent());
                        return;
                    }
                    File outputFile = new File(dir.getPath() + File.separator + inputFile.getName());
                    if (!outputFile.exists() || KeyboardHero.confirm(""Que_FileExistsOverwrite"")) {
                        final FileChannel inChannel = new FileInputStream(inputFile).getChannel();
                        inChannel.transferTo(0, inChannel.size(), new FileOutputStream(outputFile).getChannel());
                    }
                } catch (Exception ex) {
                    Util.getMsg(Util.getMsg(""Err_CouldntImportSong""), ex.toString());
                }
                SongSelector.refresh();
            }
        });
        spanel.add(button = new JButton());
        Util.updateButtonText(button, ""Delete"");
        button.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (KeyboardHero.confirm(Util.getMsg(""Que_SureToDelete""))) {
                    try {
                        new File(songSelector.getSelectedFile().toURI()).delete();
                    } catch (Exception ex) {
                        Util.error(Util.getMsg(""Err_CouldntDeleteFile""), ex.toString());
                    }
                    SongSelector.refresh();
                }
            }
        });
        panel.add(spanel = new JPanel(), BorderLayout.CENTER);
        spanel.setLayout(new FlowLayout());
        spanel.add(button = new JButton());
        Util.updateButtonText(button, ""Close"");
        button.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                close();
            }
        });
        spanel.add(button = new JButton());
        Util.updateButtonText(button, ""Play"");
        button.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                Game.newGame(songSelector.getSelectedFile());
                close();
            }
        });
        panel.add(spanel = new JPanel(), BorderLayout.EAST);
        spanel.add(button = new JButton());
        Util.updateButtonText(button, ""Refresh"");
        button.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                SongSelector.refresh();
            }
        });
        getRootPane().setDefaultButton(button);
        instance = this;
    }
"
"    private String MD5Sum(String input) {
        String hashtext = null;
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            md.reset();
            md.update(input.getBytes());
            byte[] digest = md.digest();
            BigInteger bigInt = new BigInteger(1, digest);
            hashtext = bigInt.toString(16);
            while (hashtext.length() < 32) {
                hashtext = ""0"" + hashtext;
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hashtext;
    }
","    public boolean isPasswordCorrect(String attempt) {
        try {
            MessageDigest digest = MessageDigest.getInstance(attempt);
            digest.update(salt);
            digest.update(attempt.getBytes(""UTF-8""));
            byte[] attemptHash = digest.digest();
            return attemptHash.equals(hash);
        } catch (UnsupportedEncodingException ex) {
            Logger.getLogger(UserRecord.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(UserRecord.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        }
    }
"
"    public static String md5(String input) {
        byte[] temp;
        try {
            MessageDigest messageDigest;
            messageDigest = MessageDigest.getInstance(""MD5"");
            messageDigest.update(input.getBytes());
            temp = messageDigest.digest();
        } catch (Exception e) {
            return null;
        }
        return MyUtils.byte2HexStr(temp);
    }
","        public final String hashPassword(final String password) {
            try {
                if (salt == null) {
                    salt = new byte[16];
                    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                    sr.setSeed(System.currentTimeMillis());
                    sr.nextBytes(salt);
                }
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(salt);
                md.update(password.getBytes(""UTF-8""));
                byte[] hash = md.digest();
                for (int i = 0; i < (1999); i++) {
                    md.reset();
                    hash = md.digest(hash);
                }
                return byteToString(hash, 60);
            } catch (Exception exception) {
                log.error(exception);
                return null;
            }
        }
"
"    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
","    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println(""\n"" + src + "": not an ACRNEMA stream!"");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println(""\n"" + src + "": contains UIDs!"" + "" => probable already DICOM - do not convert"");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println(""\n"" + src + "": mismatch pixel data length!"" + "" => do not convert"");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, ""MONOCHROME2"");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
"
"    public boolean copyFile(File destinationFolder, File fromFile) {
        boolean result = false;
        String toFileName = destinationFolder.getAbsolutePath() + ""/"" + fromFile.getName();
        File toFile = new File(toFileName);
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (from != null) {
                try {
                    from.close();
                } catch (IOException e2) {
                    e2.printStackTrace();
                }
                if (to != null) {
                    try {
                        to.close();
                        result = true;
                    } catch (IOException e3) {
                        e3.printStackTrace();
                    }
                }
            }
        }
        return result;
    }
","    private boolean saveLOBDataToFileSystem() {
        if ("""".equals(m_attachmentPathRoot)) {
            log.severe(""no attachmentPath defined"");
            return false;
        }
        if (m_items == null || m_items.size() == 0) {
            setBinaryData(null);
            return true;
        }
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        try {
            final DocumentBuilder builder = factory.newDocumentBuilder();
            final Document document = builder.newDocument();
            final Element root = document.createElement(""attachments"");
            document.appendChild(root);
            document.setXmlStandalone(true);
            for (int i = 0; i < m_items.size(); i++) {
                log.fine(m_items.get(i).toString());
                File entryFile = m_items.get(i).getFile();
                final String path = entryFile.getAbsolutePath();
                log.fine(path + "" - "" + m_attachmentPathRoot);
                if (!path.startsWith(m_attachmentPathRoot)) {
                    log.fine(""move file: "" + path);
                    FileChannel in = null;
                    FileChannel out = null;
                    try {
                        final File destFolder = new File(m_attachmentPathRoot + File.separator + getAttachmentPathSnippet());
                        if (!destFolder.exists()) {
                            if (!destFolder.mkdirs()) {
                                log.warning(""unable to create folder: "" + destFolder.getPath());
                            }
                        }
                        final File destFile = new File(m_attachmentPathRoot + File.separator + getAttachmentPathSnippet() + File.separator + entryFile.getName());
                        in = new FileInputStream(entryFile).getChannel();
                        out = new FileOutputStream(destFile).getChannel();
                        in.transferTo(0, in.size(), out);
                        in.close();
                        out.close();
                        if (entryFile.exists()) {
                            if (!entryFile.delete()) {
                                entryFile.deleteOnExit();
                            }
                        }
                        entryFile = destFile;
                    } catch (IOException e) {
                        e.printStackTrace();
                        log.severe(""unable to copy file "" + entryFile.getAbsolutePath() + "" to "" + m_attachmentPathRoot + File.separator + getAttachmentPathSnippet() + File.separator + entryFile.getName());
                    } finally {
                        if (in != null && in.isOpen()) {
                            in.close();
                        }
                        if (out != null && out.isOpen()) {
                            out.close();
                        }
                    }
                }
                final Element entry = document.createElement(""entry"");
                entry.setAttribute(""name"", getEntryName(i));
                String filePathToStore = entryFile.getAbsolutePath();
                filePathToStore = filePathToStore.replaceFirst(m_attachmentPathRoot.replaceAll(""\\\\"", ""\\\\\\\\""), ATTACHMENT_FOLDER_PLACEHOLDER);
                log.fine(filePathToStore);
                entry.setAttribute(""file"", filePathToStore);
                root.appendChild(entry);
            }
            final Source source = new DOMSource(document);
            final ByteArrayOutputStream bos = new ByteArrayOutputStream();
            final Result result = new StreamResult(bos);
            final Transformer xformer = TransformerFactory.newInstance().newTransformer();
            xformer.transform(source, result);
            final byte[] xmlData = bos.toByteArray();
            log.fine(bos.toString());
            setBinaryData(xmlData);
            return true;
        } catch (Exception e) {
            log.log(Level.SEVERE, ""saveLOBData"", e);
        }
        setBinaryData(null);
        return false;
    }
"
"    public int addLocationInfo(int id, double lattitude, double longitude) {
        int ret = 0;
        Connection conn = null;
        PreparedStatement psmt = null;
        try {
            String sql = ""insert into kddb.location_info (user_id, latitude, longitude) values(?, ?, ?)"";
            conn = getConnection();
            psmt = conn.prepareStatement(sql);
            psmt.setInt(1, id);
            psmt.setDouble(2, lattitude);
            psmt.setDouble(3, longitude);
            ret = psmt.executeUpdate();
            if (ret == 1) {
                conn.commit();
            } else {
                conn.rollback();
            }
        } catch (SQLException ex) {
            log.error(""[addLocationInfo]"", ex);
        } finally {
            endProsess(conn, psmt, null, null);
        }
        return ret;
    }
","    private int renumberOrderBy(long tableID) throws SnapInException {
        int count = 0;
        Connection con = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            con = getDataSource().getConnection();
            con.setAutoCommit(false);
            stmt = con.createStatement();
            StringBuffer query = new StringBuffer();
            query.append(""SELECT "").append(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_ID).append("" FROM "").append(DatabaseConstants.TableName_JV_FIELDBEHAVIOR).append("" WHERE "").append(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_TABLEID).append("" = "").append(tableID).append("" ORDER BY "").append(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_ORDERBY);
            Vector rowIDVector = new Vector();
            rs = stmt.executeQuery(query.toString());
            while (rs.next()) {
                count++;
                rowIDVector.add(rs.getLong(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_ID) + """");
            }
            StringBuffer updateString = new StringBuffer();
            updateString.append(""UPDATE "").append(DatabaseConstants.TableName_JV_FIELDBEHAVIOR).append("" SET "").append(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_ORDERBY).append("" = ? WHERE "").append(DatabaseConstants.TableFieldName_JV_FIELDBEHAVIOR_ID).append("" = ?"");
            PreparedStatement pstmt = con.prepareStatement(updateString.toString());
            int orderByValue = ORDERBY_BY_DELTA_VALUE;
            Enumeration en = rowIDVector.elements();
            while (en.hasMoreElements()) {
                pstmt.setInt(1, orderByValue);
                pstmt.setString(2, en.nextElement().toString());
                orderByValue += ORDERBY_BY_DELTA_VALUE;
                pstmt.executeUpdate();
            }
            con.setAutoCommit(true);
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (java.sql.SQLException e) {
            if (con == null) {
                logger.error(""java.sql.SQLException"", e);
            } else {
                try {
                    logger.error(""Transaction is being rolled back."");
                    con.rollback();
                    con.setAutoCommit(true);
                } catch (java.sql.SQLException e2) {
                    logger.error(""java.sql.SQLException"", e2);
                }
            }
        } catch (Exception e) {
            logger.error(""Error occured during RenumberOrderBy"", e);
        } finally {
            getDataSourceHelper().releaseResources(con, stmt, rs);
        }
        return count;
    }
"
"    public String postEvent(EventDocument eventDoc, Map attachments) {
        if (eventDoc == null || eventDoc.getEvent() == null) return null;
        if (queue == null) {
            sendEvent(eventDoc, attachments);
            return eventDoc.getEvent().getEventId();
        }
        if (attachments != null) {
            Iterator iter = attachments.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                if (entry.getValue() instanceof DataHandler) {
                    File file = new File(attachmentStorge + ""/"" + GuidUtil.generate() + entry.getKey());
                    try {
                        IOUtils.copy(((DataHandler) entry.getValue()).getInputStream(), new FileOutputStream(file));
                        entry.setValue(file);
                    } catch (IOException err) {
                        err.printStackTrace();
                    }
                }
            }
        }
        InternalEventObject eventObj = new InternalEventObject();
        eventObj.setEventDocument(eventDoc);
        eventObj.setAttachments(attachments);
        eventObj.setSessionContext(SessionContextUtil.getCurrentContext());
        eventDoc.getEvent().setEventId(GuidUtil.generate());
        getQueue().post(eventObj);
        return eventDoc.getEvent().getEventId();
    }
","    public static void copyFile(File source, File dest) throws IOException {
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (FileNotFoundException fnfe) {
            Log.debug(fnfe);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
"
"    protected void doRestoreOrganizeTypeRelation() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strDelQuery = ""DELETE FROM "" + Common.ORGANIZE_TYPE_RELATION_TABLE;
        String strSelQuery = ""SELECT parent_organize_type,child_organize_type "" + ""FROM "" + Common.ORGANIZE_TYPE_RELATION_B_TABLE + "" "" + ""WHERE version_no = ?"";
        String strInsQuery = ""INSERT INTO "" + Common.ORGANIZE_TYPE_RELATION_TABLE + "" "" + ""(parent_organize_type,child_organize_type) "" + ""VALUES (?,?)"";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strDelQuery);
                ps.executeUpdate();
                ps = con.prepareStatement(strSelQuery);
                ps.setInt(1, this.versionNO);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setString(1, result.getString(""parent_organize_type""));
                    ps.setString(2, result.getString(""child_organize_type""));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException(""Organize_backup.doRestoreOrganizeTypeRelation(): ERROR Inserting data "" + ""in T_SYS_ORGANIZE_TYPE_RELATION INSERT !! resultCount = "" + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException(""Organize_backup.doRestoreOrganizeTypeRelation(): SQLException:  "" + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException(""Organize_backup.doRestoreOrganizeTypeRelation(): SQLException while committing or rollback"");
        }
    }
","    private void addDocToDB(String action, DataSource database) {
        String typeOfDoc = findTypeOfDoc(action).trim().toLowerCase();
        Connection con = null;
        try {
            con = database.getConnection();
            con.setAutoCommit(false);
            checkDupDoc(typeOfDoc, con);
            String add = ""insert into "" + typeOfDoc + "" values( ?, ?, ?, ?, ?, ?, ? )"";
            PreparedStatement prepStatement = con.prepareStatement(add);
            prepStatement.setString(1, selectedCourse.getCourseId());
            prepStatement.setString(2, selectedCourse.getAdmin());
            prepStatement.setTimestamp(3, getTimeStamp());
            prepStatement.setString(4, getLink());
            prepStatement.setString(5, homePage.getUser());
            prepStatement.setString(6, getText());
            prepStatement.setString(7, getTitle());
            prepStatement.executeUpdate();
            prepStatement.close();
            con.commit();
        } catch (Exception e) {
            sqlError = true;
            e.printStackTrace();
            if (con != null) try {
                con.rollback();
            } catch (Exception logOrIgnore) {
            }
            try {
                throw e;
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        } finally {
            if (con != null) try {
                con.close();
            } catch (Exception logOrIgnore) {
            }
        }
    }
"
"    private static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
","    @Override
    protected int run(CmdLineParser parser) {
        final List<String> args = parser.getRemainingArgs();
        if (args.isEmpty()) {
            System.err.println(""summarysort :: WORKDIR not given."");
            return 3;
        }
        if (args.size() == 1) {
            System.err.println(""summarysort :: INPATH not given."");
            return 3;
        }
        final String outS = (String) parser.getOptionValue(outputDirOpt);
        final Path wrkDir = new Path(args.get(0)), in = new Path(args.get(1)), out = outS == null ? null : new Path(outS);
        final boolean verbose = parser.getBoolean(verboseOpt);
        final Configuration conf = getConf();
        final Timer t = new Timer();
        try {
            @SuppressWarnings(""deprecation"") final int maxReduceTasks = new JobClient(new JobConf(conf)).getClusterStatus().getMaxReduceTasks();
            conf.setInt(""mapred.reduce.tasks"", Math.max(1, maxReduceTasks * 9 / 10));
            final Job job = sortOne(conf, in, wrkDir, ""summarysort"", """");
            System.out.printf(""summarysort :: Waiting for job completion...\n"");
            t.start();
            if (!job.waitForCompletion(verbose)) {
                System.err.println(""summarysort :: Job failed."");
                return 4;
            }
            System.out.printf(""summarysort :: Job complete in %d.%03d s.\n"", t.stopS(), t.fms());
        } catch (IOException e) {
            System.err.printf(""summarysort :: Hadoop error: %s\n"", e);
            return 4;
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (out != null) try {
            System.out.println(""summarysort :: Merging output..."");
            t.start();
            final FileSystem srcFS = wrkDir.getFileSystem(conf);
            final FileSystem dstFS = out.getFileSystem(conf);
            final OutputStream outs = dstFS.create(out);
            final FileStatus[] parts = srcFS.globStatus(new Path(wrkDir, in.getName() + ""-[0-9][0-9][0-9][0-9][0-9][0-9]*""));
            {
                int i = 0;
                final Timer t2 = new Timer();
                for (final FileStatus part : parts) {
                    t2.start();
                    final InputStream ins = srcFS.open(part.getPath());
                    IOUtils.copyBytes(ins, outs, conf, false);
                    ins.close();
                    System.out.printf(""summarysort :: Merged part %d in %d.%03d s.\n"", ++i, t2.stopS(), t2.fms());
                }
            }
            for (final FileStatus part : parts) srcFS.delete(part.getPath(), false);
            outs.write(BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK);
            outs.close();
            System.out.printf(""summarysort :: Merging complete in %d.%03d s.\n"", t.stopS(), t.fms());
        } catch (IOException e) {
            System.err.printf(""summarysort :: Output merging failed: %s\n"", e);
            return 5;
        }
        return 0;
    }
"
"    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {
        String filePath = null;
        try {
            URL endpoint = new URL(wsdlURL);
            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();
            conn.setDoOutput(false);
            conn.setDoInput(true);
            conn.setUseCaches(false);
            conn.setRequestMethod(""GET"");
            conn.setRequestProperty(""Accept"", ""text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5"");
            conn.setRequestProperty(""Connection"", ""close"");
            if (userPassword != null) {
                conn.setRequestProperty(""Authorization"", ""Basic "" + (new BASE64Encoder()).encode(userPassword.getBytes()));
            }
            InputStream is = null;
            if (conn.getResponseCode() == 200) {
                is = conn.getInputStream();
            } else {
                is = conn.getErrorStream();
                InputStreamReader isr = new InputStreamReader(is);
                StringWriter sw = new StringWriter();
                char[] buf = new char[200];
                int read = 0;
                while (read != -1) {
                    read = isr.read(buf);
                    sw.write(buf);
                }
                throw new WiseConnectionException(""Remote server's response is an error: "" + sw.toString());
            }
            File file = new File(tmpDeployDir, new StringBuffer(""Wise"").append(IDGenerator.nextVal()).append("".xml"").toString());
            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));
            IOUtils.copyStream(fos, is);
            fos.close();
            is.close();
            filePath = file.getPath();
        } catch (WiseConnectionException wce) {
            throw wce;
        } catch (Exception e) {
            throw new WiseConnectionException(""Wsdl download failed!"", e);
        }
        return filePath;
    }
","        @Override
        public void run() {
            try {
                IOUtils.copy(_is, processOutStr);
            } catch (final IOException ioe) {
                proc.destroy();
            } finally {
                IOUtils.closeQuietly(_is);
                IOUtils.closeQuietly(processOutStr);
            }
        }
"
"    public static String hash(String plainText) throws Exception {
        MessageDigest m = MessageDigest.getInstance(""MD5"");
        m.update(plainText.getBytes(), 0, plainText.length());
        String hash = new BigInteger(1, m.digest()).toString(16);
        if (hash.length() == 31) {
            hash = ""0"" + hash;
        }
        return hash;
    }
","    public static String md5(String senha) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            System.out.println(""Ocorreu NoSuchAlgorithmException"");
        }
        md.update(senha.getBytes());
        byte[] xx = md.digest();
        String n2 = null;
        StringBuffer resposta = new StringBuffer();
        for (int i = 0; i < xx.length; i++) {
            n2 = Integer.toHexString(0XFF & ((int) (xx[i])));
            if (n2.length() < 2) {
                n2 = ""0"" + n2;
            }
            resposta.append(n2);
        }
        return resposta.toString();
    }
"
"    public static void copyFile(final String inFile, final String outFile) {
        FileChannel in = null;
        FileChannel out = null;
        try {
            in = new FileInputStream(inFile).getChannel();
            out = new FileOutputStream(outFile).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (final Exception e) {
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (final Exception e) {
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (final Exception e) {
                }
            }
        }
    }
","    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
"
"    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
","    public void constructAssociationView() {
        String className;
        String methodName;
        String field;
        boolean foundRead = false;
        boolean foundWrite = false;
        boolean classWritten = false;
        try {
            AssocView = new BufferedWriter(new FileWriter(""InfoFiles/AssociationView.txt""));
            FileInputStream fstreamPC = new FileInputStream(""InfoFiles/PrincipleClassGroup.txt"");
            DataInputStream inPC = new DataInputStream(fstreamPC);
            BufferedReader PC = new BufferedReader(new InputStreamReader(inPC));
            while ((field = PC.readLine()) != null) {
                className = field;
                AssocView.write(className);
                AssocView.newLine();
                classWritten = true;
                while ((methodName = PC.readLine()) != null) {
                    if (methodName.contentEquals(""EndOfClass"")) break;
                    AssocView.write(""StartOfMethod"");
                    AssocView.newLine();
                    AssocView.write(methodName);
                    AssocView.newLine();
                    for (int i = 0; i < readFileCount && foundRead == false; i++) {
                        if (methodName.compareTo(readArray[i]) == 0) {
                            foundRead = true;
                            for (int j = 1; readArray[i + j].compareTo(""EndOfMethod"") != 0; j++) {
                                if (readArray[i + j].indexOf(""."") > 0) {
                                    field = readArray[i + j].substring(0, readArray[i + j].indexOf("".""));
                                    if (isPrincipleClass(field) == true) {
                                        AssocView.write(readArray[i + j]);
                                        AssocView.newLine();
                                    }
                                }
                            }
                        }
                    }
                    for (int i = 0; i < writeFileCount && foundWrite == false; i++) {
                        if (methodName.compareTo(writeArray[i]) == 0) {
                            foundWrite = true;
                            for (int j = 1; writeArray[i + j].compareTo(""EndOfMethod"") != 0; j++) {
                                if (writeArray[i + j].indexOf(""."") > 0) {
                                    field = writeArray[i + j].substring(0, writeArray[i + j].indexOf("".""));
                                    if (isPrincipleClass(field) == true) {
                                        AssocView.write(writeArray[i + j]);
                                        AssocView.newLine();
                                    }
                                }
                            }
                        }
                    }
                    AssocView.write(""EndOfMethod"");
                    AssocView.newLine();
                    foundRead = false;
                    foundWrite = false;
                }
                if (classWritten == true) {
                    AssocView.write(""EndOfClass"");
                    AssocView.newLine();
                    classWritten = false;
                }
            }
            PC.close();
            AssocView.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
"    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
","    public static byte[] hash(String identifier) {
        if (function.equals(""SHA-1"")) {
            try {
                MessageDigest md = MessageDigest.getInstance(function);
                md.reset();
                byte[] code = md.digest(identifier.getBytes());
                byte[] value = new byte[KEY_LENGTH / 8];
                int shrink = code.length / value.length;
                int bitCount = 1;
                for (int j = 0; j < code.length * 8; j++) {
                    int currBit = ((code[j / 8] & (1 << (j % 8))) >> j % 8);
                    if (currBit == 1) bitCount++;
                    if (((j + 1) % shrink) == 0) {
                        int shrinkBit = (bitCount % 2 == 0) ? 0 : 1;
                        value[j / shrink / 8] |= (shrinkBit << ((j / shrink) % 8));
                        bitCount = 1;
                    }
                }
                return value;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        if (function.equals(""CRC32"")) {
            CRC32 crc32 = new CRC32();
            crc32.reset();
            crc32.update(identifier.getBytes());
            long code = crc32.getValue();
            code &= (0xffffffffffffffffL >>> (64 - KEY_LENGTH));
            byte[] value = new byte[KEY_LENGTH / 8];
            for (int i = 0; i < value.length; i++) {
                value[value.length - i - 1] = (byte) ((code >> 8 * i) & 0xff);
            }
            return value;
        }
        if (function.equals(""Java"")) {
            int code = identifier.hashCode();
            code &= (0xffffffff >>> (32 - KEY_LENGTH));
            byte[] value = new byte[KEY_LENGTH / 8];
            for (int i = 0; i < value.length; i++) {
                value[value.length - i - 1] = (byte) ((code >> 8 * i) & 0xff);
            }
            return value;
        }
        return null;
    }
"
"    private static <OS extends OutputStream> OS getUnzipAndDecodeOutputStream(InputStream inputStream, final OS outputStream) {
        final PipedOutputStream pipedOutputStream = new PipedOutputStream();
        final List<Throwable> ungzipThreadThrowableList = new LinkedList<Throwable>();
        Writer decoderWriter = null;
        Thread ungzipThread = null;
        try {
            final PipedInputStream pipedInputStream = new PipedInputStream(pipedOutputStream);
            ungzipThread = new Thread(new Runnable() {

                public void run() {
                    GZIPInputStream gzipInputStream = null;
                    try {
                        gzipInputStream = new GZIPInputStream(pipedInputStream);
                        IOUtils.copy(gzipInputStream, outputStream);
                    } catch (Throwable t) {
                        ungzipThreadThrowableList.add(t);
                    } finally {
                        IOUtils.closeQuietly(gzipInputStream);
                        IOUtils.closeQuietly(pipedInputStream);
                    }
                }
            });
            decoderWriter = Base64.newDecoder(pipedOutputStream);
            ungzipThread.start();
            IOUtils.copy(inputStream, decoderWriter, DVK_MESSAGE_CHARSET);
            decoderWriter.flush();
            pipedOutputStream.flush();
        } catch (IOException e) {
            throw new RuntimeException(""failed to unzip and decode input"", e);
        } finally {
            IOUtils.closeQuietly(decoderWriter);
            IOUtils.closeQuietly(pipedOutputStream);
            if (ungzipThread != null) {
                try {
                    ungzipThread.join();
                } catch (InterruptedException ie) {
                    throw new RuntimeException(""thread interrupted while for ungzip thread to finish"", ie);
                }
            }
        }
        if (!ungzipThreadThrowableList.isEmpty()) {
            throw new RuntimeException(""ungzip failed"", ungzipThreadThrowableList.get(0));
        }
        return outputStream;
    }
","    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
","    public void backupXML() {
        try {
            TimeStamp timeStamp = new TimeStamp();
            String fnameIn = this.fnameXML();
            String pathBackup = this.pathXML + ""\\Backup\\"";
            String fnameOut = fnameIn.substring(fnameIn.indexOf(this.fname), fnameIn.length());
            fnameOut = fnameOut.substring(0, fnameOut.indexOf(""xml""));
            fnameOut = pathBackup + fnameOut + timeStamp.now(""yyyyMMdd-kkmmss"") + "".xml"";
            System.out.println(""fnameIn: "" + fnameIn);
            System.out.println(""fnameOut: "" + fnameOut);
            FileChannel in = new FileInputStream(fnameIn).getChannel();
            FileChannel out = new FileOutputStream(fnameOut).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (Exception e) {
            central.inform(""ORM.backupXML: "" + e.toString());
        }
    }
"
"    public String getHash(String str) {
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            md.update(str.getBytes());
            byte[] toChapter1Digest = md.digest();
            return Keystore.hexEncode(toChapter1Digest);
        } catch (Exception e) {
            logger.error(""Error in creating DN hash: "" + e.getMessage());
            return null;
        }
    }
","    public static String encripta(String senha) throws GCIException {
        LOGGER.debug(INICIANDO_METODO + ""encripta(String)"");
        try {
            MessageDigest digest = MessageDigest.getInstance(""MD5"");
            digest.update(senha.getBytes());
            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(digest.digest());
        } catch (NoSuchAlgorithmException e) {
            LOGGER.fatal(e.getMessage(), e);
            throw new GCIException(e);
        } finally {
            LOGGER.debug(FINALIZANDO_METODO + ""encripta(String)"");
        }
    }
"
"    private void checkLogin(String email, String password) throws JspTagException {
        String cryptedPassword;
        try {
            MessageDigest crypt = MessageDigest.getInstance(""MD5"");
            crypt.update(password.getBytes());
            byte digest[] = crypt.digest();
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < digest.length; i++) {
                hexString.append(hexDigit(digest[i]));
            }
            cryptedPassword = hexString.toString();
            crypt.reset();
            InitialContext context = new InitialContext();
            java.lang.Object homeRef = context.lookup(""java:comp/env/ejb/Value"");
            ValueHome valueHome = (ValueHome) PortableRemoteObject.narrow(homeRef, ValueHome.class);
            Value value = valueHome.findByPasswordCheck(email, cryptedPassword);
            pageContext.setAttribute(""validLogin"", new Boolean(true));
            HttpSession session = pageContext.getSession();
            session.setAttribute(""jspShop.userID"", value.getObjectID());
        } catch (NoSuchAlgorithmException e) {
            System.err.println(""jspShop: Could not get instance of MD5 algorithm. Please fix this!"" + e.getMessage());
            e.printStackTrace();
            throw new JspTagException(""Error crypting password!: "" + e.getMessage());
        } catch (ObjectNotFoundException e) {
            pageContext.setAttribute(""validLogin"", new Boolean(false));
        } catch (NamingException e) {
            System.err.println(""jspShop: Could not initialise context in LoginTag"");
            e.printStackTrace();
        } catch (RemoteException e) {
            System.err.println(""jspShop: Could not connect to container in LoginTag"");
        } catch (FinderException e) {
            System.err.println(""jspShop: Error using finderQuery in LoginTag"");
        }
    }
","    @edu.umd.cs.findbugs.annotations.SuppressWarnings({ ""DLS"", ""REC"" })
    public static String md5Encode(String val) {
        String output = null;
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            md.update(val.getBytes());
            byte[] digest = md.digest();
            output = base64Encode(digest);
        } catch (Exception e) {
        }
        return output;
    }
"
"    private String[] verifyConnection(Socket clientConnection) throws Exception {
        List<String> requestLines = new ArrayList<String>();
        InputStream is = clientConnection.getInputStream();
        BufferedReader in = new BufferedReader(new InputStreamReader(is));
        StringTokenizer st = new StringTokenizer(in.readLine());
        if (!st.hasMoreTokens()) {
            throw new IllegalArgumentException(""There's no method token in this connection"");
        }
        String method = st.nextToken();
        if (!st.hasMoreTokens()) {
            throw new IllegalArgumentException(""There's no URI token in this connection"");
        }
        String uri = decodePercent(st.nextToken());
        if (!st.hasMoreTokens()) {
            throw new IllegalArgumentException(""There's no version token in this connection"");
        }
        String version = st.nextToken();
        Properties parms = new Properties();
        int qmi = uri.indexOf('?');
        if (qmi >= 0) {
            decodeParms(uri.substring(qmi + 1), parms);
            uri = decodePercent(uri.substring(0, qmi));
        }
        String params = """";
        if (parms.size() > 0) {
            params = ""?"";
            for (Object key : parms.keySet()) {
                params = params + key + ""="" + parms.getProperty(((String) key)) + ""&"";
            }
            params = params.substring(0, params.length() - 1).replace("" "", ""%20"");
        }
        logger.debug(""HTTP Request: "" + method + "" "" + uri + params + "" "" + version);
        requestLines.add(method + "" "" + uri + params + "" "" + version);
        Properties headerVars = new Properties();
        String line;
        String currentBoundary = null;
        Stack<String> boundaryStack = new Stack<String>();
        boolean readingBoundary = false;
        String additionalData = """";
        while (in.ready() && (line = in.readLine()) != null) {
            if (line.equals("""") && (headerVars.get(""Content-Type"") == null || headerVars.get(""Content-Length"") == null)) {
                break;
            }
            logger.debug(""HTTP Request Header: "" + line);
            if (line.contains("": "")) {
                String vals[] = line.split("": "");
                headerVars.put(vals[0].trim(), vals[1].trim());
            }
            if (!readingBoundary && line.contains("": "")) {
                if (line.contains(""boundary="")) {
                    currentBoundary = line.split(""boundary="")[1].trim();
                    boundaryStack.push(""--"" + currentBoundary);
                }
                continue;
            } else if (line.equals("""") && boundaryStack.isEmpty()) {
                int val = Integer.parseInt((String) headerVars.get(""Content-Length""));
                if (headerVars.getProperty(""Content-Type"").contains(""x-www-form-urlencoded"")) {
                    char buf[] = new char[val];
                    int read = in.read(buf);
                    line = String.valueOf(buf, 0, read);
                    additionalData = line;
                    logger.debug(""HTTP Request Header Form Parameters: "" + line);
                }
            } else if (line.equals(boundaryStack.peek()) && !readingBoundary) {
                readingBoundary = true;
            } else if (line.equals(boundaryStack.peek()) && readingBoundary) {
                readingBoundary = false;
            } else if (line.contains("": "") && readingBoundary) {
                if (method.equalsIgnoreCase(""PUT"")) {
                    if (line.contains(""form-data; "")) {
                        String formValues = line.split(""form-data; "")[1];
                        for (String varValue : formValues.replace(""\"""", """").split(""; "")) {
                            String[] vV = varValue.split(""="");
                            vV[0] = decodePercent(vV[0]);
                            vV[1] = decodePercent(vV[1]);
                            headerVars.put(vV[0], vV[1]);
                        }
                    }
                }
            } else if (line.contains("""") && readingBoundary && !boundaryStack.isEmpty() && headerVars.get(""filename"") != null) {
                int length = Integer.parseInt(headerVars.getProperty(""Content-Length""));
                if (headerVars.getProperty(""Content-Transfer-Encoding"").contains(""binary"")) {
                    File uploadFilePath = new File(VOctopusConfigurationManager.WebServerProperties.HTTPD_CONF.getPropertyValue(""TempDirectory""));
                    if (!uploadFilePath.exists()) {
                        logger.error(""Temporaty dir does not exist: "" + uploadFilePath.getCanonicalPath());
                    }
                    if (!uploadFilePath.isDirectory()) {
                        logger.error(""Temporary dir is not a directory: "" + uploadFilePath.getCanonicalPath());
                    }
                    if (!uploadFilePath.canWrite()) {
                        logger.error(""VOctopus Webserver doesn't have permissions to write on temporary dir: "" + uploadFilePath.getCanonicalPath());
                    }
                    FileOutputStream out = null;
                    try {
                        String putUploadPath = uploadFilePath.getAbsolutePath() + ""/"" + headerVars.getProperty(""filename"");
                        out = new FileOutputStream(putUploadPath);
                        OutputStream outf = new BufferedOutputStream(out);
                        int c;
                        while (in.ready() && (c = in.read()) != -1 && length-- > 0) {
                            outf.write(c);
                        }
                    } finally {
                        if (out != null) {
                            out.close();
                        }
                    }
                    File copied = new File(VOctopusConfigurationManager.getInstance().getDocumentRootPath() + uri + headerVars.get(""filename""));
                    File tempFile = new File(VOctopusConfigurationManager.WebServerProperties.HTTPD_CONF.getPropertyValue(""TempDirectory"") + ""/"" + headerVars.get(""filename""));
                    FileChannel ic = new FileInputStream(tempFile.getAbsolutePath()).getChannel();
                    FileChannel oc = new FileOutputStream(copied.getAbsolutePath()).getChannel();
                    ic.transferTo(0, ic.size(), oc);
                    ic.close();
                    oc.close();
                }
            }
        }
        for (Object var : headerVars.keySet()) {
            requestLines.add(var + "": "" + headerVars.get(var));
        }
        if (!additionalData.equals("""")) {
            requestLines.add(""ADDITIONAL"" + additionalData);
        }
        return requestLines.toArray(new String[requestLines.size()]);
    }
","    private static void convertToOnline(final String filePath, final DocuBean docuBean) throws Exception {
        File source = new File(filePath + File.separator + docuBean.getFileName());
        File dir = new File(filePath + File.separator + docuBean.getId());
        if (!dir.exists()) {
            dir.mkdir();
        }
        File in = source;
        boolean isSpace = false;
        if (source.getName().indexOf("" "") != -1) {
            in = new File(StringUtils.replace(source.getName(), "" "", """"));
            try {
                IOUtils.copyFile(source, in);
            } catch (IOException e) {
                e.printStackTrace();
            }
            isSpace = true;
        }
        File finalPdf = null;
        try {
            String outPath = dir.getAbsolutePath();
            final File pdf = DocViewerConverter.toPDF(in, outPath);
            convertToSwf(pdf, outPath, docuBean);
            finalPdf = new File(outPath + File.separator + FileUtils.getFilePrefix(StringUtils.replace(source.getName(), "" "", """")) + ""_decrypted.pdf"");
            if (!finalPdf.exists()) {
                finalPdf = pdf;
            }
            pdfByFirstPageToJpeg(finalPdf, outPath, docuBean);
            if (docuBean.getSuccess() == 2 && dir.listFiles().length < 2) {
                docuBean.setSuccess(3);
            }
        } catch (Exception e) {
            throw e;
        } finally {
            if (isSpace) {
                IOUtils.delete(in);
            }
        }
    }
"
"    public String getData() throws ValueFormatException, RepositoryException, IOException {
        InputStream is = getStream();
        StringWriter sw = new StringWriter();
        IOUtils.copy(is, sw, ""UTF-8"");
        IOUtils.closeQuietly(is);
        return sw.toString();
    }
","    public static void unzip(final File file, final ZipFile zipFile, final File targetDirectory) throws PtException {
        LOG.info(""Unzipping zip file '"" + file.getAbsolutePath() + ""' to directory "" + ""'"" + targetDirectory.getAbsolutePath() + ""'."");
        assert (file.exists() && file.isFile());
        if (targetDirectory.exists() == false) {
            LOG.debug(""Creating target directory."");
            if (targetDirectory.mkdirs() == false) {
                throw new PtException(""Could not create target directory at "" + ""'"" + targetDirectory.getAbsolutePath() + ""'!"");
            }
        }
        ZipInputStream zipin = null;
        try {
            zipin = new ZipInputStream(new FileInputStream(file));
            ZipEntry nextZipEntry = zipin.getNextEntry();
            while (nextZipEntry != null) {
                LOG.debug(""Unzipping entry '"" + nextZipEntry.getName() + ""'."");
                if (nextZipEntry.isDirectory()) {
                    LOG.debug(""Skipping directory."");
                    continue;
                }
                final File targetFile = new File(targetDirectory, nextZipEntry.getName());
                final File parentTargetFile = targetFile.getParentFile();
                if (parentTargetFile.exists() == false) {
                    LOG.debug(""Creating directory '"" + parentTargetFile.getAbsolutePath() + ""'."");
                    if (parentTargetFile.mkdirs() == false) {
                        throw new PtException(""Could not create target directory at "" + ""'"" + parentTargetFile.getAbsolutePath() + ""'!"");
                    }
                }
                InputStream input = null;
                FileOutputStream output = null;
                try {
                    input = zipFile.getInputStream(nextZipEntry);
                    if (targetFile.createNewFile() == false) {
                        throw new PtException(""Could not create target file "" + ""'"" + targetFile.getAbsolutePath() + ""'!"");
                    }
                    output = new FileOutputStream(targetFile);
                    byte[] buffer = new byte[BUFFER_SIZE];
                    int readBytes = input.read(buffer, 0, buffer.length);
                    while (readBytes > 0) {
                        output.write(buffer, 0, readBytes);
                        readBytes = input.read(buffer, 0, buffer.length);
                    }
                } finally {
                    PtCloseUtil.close(input, output);
                }
                nextZipEntry = zipin.getNextEntry();
            }
        } catch (IOException e) {
            throw new PtException(""Could not unzip file '"" + file.getAbsolutePath() + ""'!"", e);
        } finally {
            PtCloseUtil.close(zipin);
        }
    }
"
"    public static void reconstruct(final List files, final Map properties, final OutputStream fout, final String base_url, final String producer, final PageSize[] size, final List hf) throws CConvertException {
        OutputStream out = fout;
        OutputStream out2 = fout;
        boolean signed = false;
        OutputStream oldOut = null;
        File tmp = null;
        File tmp2 = null;
        try {
            tmp = File.createTempFile(""yahp"", ""pdf"");
            tmp2 = File.createTempFile(""yahp"", ""pdf"");
            oldOut = out;
            if (""true"".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_SIGNING))) {
                signed = true;
                out2 = new FileOutputStream(tmp2);
            } else {
                out2 = oldOut;
            }
            out = new FileOutputStream(tmp);
            com.lowagie.text.Document document = null;
            PdfCopy writer = null;
            boolean first = true;
            Map mapSizeDoc = new HashMap();
            int totalPage = 0;
            for (int i = 0; i < files.size(); i++) {
                final File fPDF = (File) files.get(i);
                final PdfReader reader = new PdfReader(fPDF.getAbsolutePath());
                reader.consolidateNamedDestinations();
                final int n = reader.getNumberOfPages();
                if (first) {
                    first = false;
                    document = new com.lowagie.text.Document(reader.getPageSizeWithRotation(1));
                    writer = new PdfCopy(document, out);
                    writer.setPdfVersion(PdfWriter.VERSION_1_3);
                    writer.setFullCompression();
                    if (""true"".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_ENCRYPTION))) {
                        final String password = (String) properties.get(IHtmlToPdfTransformer.PDF_ENCRYPTION_PASSWORD);
                        final int securityType = CDocumentReconstructor.getSecurityFlags(properties);
                        writer.setEncryption(PdfWriter.STRENGTH128BITS, password, null, securityType);
                    }
                    final String title = (String) properties.get(IHtmlToPdfTransformer.PDF_TITLE);
                    if (title != null) {
                        document.addTitle(title);
                    } else if (base_url != null) {
                        document.addTitle(base_url);
                    }
                    final String creator = (String) properties.get(IHtmlToPdfTransformer.PDF_CREATOR);
                    if (creator != null) {
                        document.addCreator(creator);
                    } else {
                        document.addCreator(IHtmlToPdfTransformer.VERSION);
                    }
                    final String author = (String) properties.get(IHtmlToPdfTransformer.PDF_AUTHOR);
                    if (author != null) {
                        document.addAuthor(author);
                    }
                    final String sproducer = (String) properties.get(IHtmlToPdfTransformer.PDF_PRODUCER);
                    if (sproducer != null) {
                        document.addProducer(sproducer);
                    } else {
                        document.addProducer(IHtmlToPdfTransformer.VERSION + "" - http://www.allcolor.org/YaHPConverter/ - "" + producer);
                    }
                    document.open();
                }
                PdfImportedPage page;
                for (int j = 0; j < n; ) {
                    ++j;
                    totalPage++;
                    mapSizeDoc.put("""" + totalPage, """" + i);
                    page = writer.getImportedPage(reader, j);
                    writer.addPage(page);
                }
            }
            document.close();
            out.flush();
            out.close();
            {
                final PdfReader reader = new PdfReader(tmp.getAbsolutePath());
                ;
                final int n = reader.getNumberOfPages();
                final PdfStamper stp = new PdfStamper(reader, out2);
                int i = 0;
                BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, BaseFont.EMBEDDED);
                final CHtmlToPdfFlyingSaucerTransformer trans = new CHtmlToPdfFlyingSaucerTransformer();
                while (i < n) {
                    i++;
                    int indexSize = Integer.parseInt((String) mapSizeDoc.get("""" + i));
                    final int[] dsize = size[indexSize].getSize();
                    final int[] dmargin = size[indexSize].getMargin();
                    for (final Iterator it = hf.iterator(); it.hasNext(); ) {
                        final CHeaderFooter chf = (CHeaderFooter) it.next();
                        if (chf.getSfor().equals(CHeaderFooter.ODD_PAGES) && (i % 2 == 0)) {
                            continue;
                        } else if (chf.getSfor().equals(CHeaderFooter.EVEN_PAGES) && (i % 2 != 0)) {
                            continue;
                        }
                        final String text = chf.getContent().replaceAll(""<pagenumber>"", """" + i).replaceAll(""<pagecount>"", """" + n);
                        final PdfContentByte over = stp.getOverContent(i);
                        final ByteArrayOutputStream bbout = new ByteArrayOutputStream();
                        if (chf.getType().equals(CHeaderFooter.HEADER)) {
                            trans.transform(new ByteArrayInputStream(text.getBytes(""utf-8"")), base_url, new PageSize(dsize[0] - (dmargin[0] + dmargin[1]), dmargin[3]), new ArrayList(), properties, bbout);
                        } else if (chf.getType().equals(CHeaderFooter.FOOTER)) {
                            trans.transform(new ByteArrayInputStream(text.getBytes(""utf-8"")), base_url, new PageSize(dsize[0] - (dmargin[0] + dmargin[1]), dmargin[2]), new ArrayList(), properties, bbout);
                        }
                        final PdfReader readerHF = new PdfReader(bbout.toByteArray());
                        if (chf.getType().equals(CHeaderFooter.HEADER)) {
                            over.addTemplate(stp.getImportedPage(readerHF, 1), dmargin[0], dsize[1] - dmargin[3]);
                        } else if (chf.getType().equals(CHeaderFooter.FOOTER)) {
                            over.addTemplate(stp.getImportedPage(readerHF, 1), dmargin[0], 0);
                        }
                        readerHF.close();
                    }
                }
                stp.close();
            }
            try {
                out2.flush();
            } catch (Exception ignore) {
            } finally {
                try {
                    out2.close();
                } catch (Exception ignore) {
                }
            }
            if (signed) {
                final String keypassword = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_PRIVATE_KEY_PASSWORD);
                final String password = (String) properties.get(IHtmlToPdfTransformer.PDF_ENCRYPTION_PASSWORD);
                final String keyStorepassword = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_KEYSTORE_PASSWORD);
                final String privateKeyFile = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_PRIVATE_KEY_FILE);
                final String reason = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_REASON);
                final String location = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_LOCATION);
                final boolean selfSigned = !""false"".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_SELF_SIGNING));
                PdfReader reader = null;
                if (password != null) {
                    reader = new PdfReader(tmp2.getAbsolutePath(), password.getBytes());
                } else {
                    reader = new PdfReader(tmp2.getAbsolutePath());
                }
                final KeyStore ks = selfSigned ? KeyStore.getInstance(KeyStore.getDefaultType()) : KeyStore.getInstance(""pkcs12"");
                ks.load(new FileInputStream(privateKeyFile), keyStorepassword.toCharArray());
                final String alias = (String) ks.aliases().nextElement();
                final PrivateKey key = (PrivateKey) ks.getKey(alias, keypassword.toCharArray());
                final Certificate chain[] = ks.getCertificateChain(alias);
                final PdfStamper stp = PdfStamper.createSignature(reader, oldOut, '\0');
                if (""true"".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_ENCRYPTION))) {
                    stp.setEncryption(PdfWriter.STRENGTH128BITS, password, null, CDocumentReconstructor.getSecurityFlags(properties));
                }
                final PdfSignatureAppearance sap = stp.getSignatureAppearance();
                if (selfSigned) {
                    sap.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);
                } else {
                    sap.setCrypto(key, chain, null, PdfSignatureAppearance.WINCER_SIGNED);
                }
                if (reason != null) {
                    sap.setReason(reason);
                }
                if (location != null) {
                    sap.setLocation(location);
                }
                stp.close();
                oldOut.flush();
            }
        } catch (final Exception e) {
            throw new CConvertException(""ERROR: An Exception occured while reconstructing the pdf document: "" + e.getMessage(), e);
        } finally {
            try {
                tmp.delete();
            } catch (final Exception ignore) {
            }
            try {
                tmp2.delete();
            } catch (final Exception ignore) {
            }
        }
    }
","    private void loadMap() {
        final String wordList = ""vietwordlist.txt"";
        try {
            File dataFile = new File(supportDir, wordList);
            if (!dataFile.exists()) {
                final ReadableByteChannel input = Channels.newChannel(ClassLoader.getSystemResourceAsStream(""dict/"" + dataFile.getName()));
                final FileChannel output = new FileOutputStream(dataFile).getChannel();
                output.transferFrom(input, 0, 1000000L);
                input.close();
                output.close();
            }
            long fileLastModified = dataFile.lastModified();
            if (map == null) {
                map = new HashMap<String, String>();
            } else {
                if (fileLastModified <= mapLastModified) {
                    return;
                }
                map.clear();
            }
            mapLastModified = fileLastModified;
            BufferedReader bs = new BufferedReader(new InputStreamReader(new FileInputStream(dataFile), ""UTF-8""));
            String accented;
            while ((accented = bs.readLine()) != null) {
                String plain = VietUtilities.stripDiacritics(accented);
                map.put(plain.toLowerCase(), accented);
            }
            bs.close();
        } catch (IOException e) {
            map = null;
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, myResources.getString(""Cannot_find_\"""") + wordList + myResources.getString(""\""_in\n"") + supportDir.toString(), VietPad.APP_NAME, JOptionPane.ERROR_MESSAGE);
        }
    }
"
"    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
","    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
"
"    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
","    public boolean copier(String source, String nomFichierSource, java.io.File destination) {
        boolean resultat = false;
        OutputStream tmpOut;
        try {
            tmpOut = new BufferedOutputStream(new FileOutputStream(nomFichierSource + ""001.tmp""));
            InputStream is = getClass().getResourceAsStream(source + nomFichierSource);
            int i;
            while ((i = is.read()) != -1) tmpOut.write(i);
            tmpOut.close();
            is.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        FileChannel in = null;
        FileChannel out = null;
        try {
            in = new FileInputStream(new File(nomFichierSource + ""001.tmp"")).getChannel();
            out = new FileOutputStream(destination).getChannel();
            in.transferTo(0, in.size(), out);
            resultat = true;
        } catch (java.io.FileNotFoundException f) {
        } catch (java.io.IOException e) {
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                }
            }
        }
        new File(nomFichierSource + ""001.tmp"").delete();
        return (resultat);
    }
"
"    public static void main(String[] args) throws IOException {
        String uri = ""hdfs://localhost:8020/user/leeing/maxtemp/sample.txt"";
        Configuration conf = new Configuration();
        FileSystem fs = FileSystem.get(URI.create(uri), conf);
        InputStream in = null;
        try {
            in = fs.open(new Path(uri));
            IOUtils.copyBytes(in, System.out, 8192, false);
        } finally {
            IOUtils.closeStream(in);
        }
    }
","    public boolean backupLastAuditSchema(File lastAuditSchema) {
        boolean isBkupFileOK = false;
        String writeTimestamp = DateFormatUtils.format(new java.util.Date(), configFile.getTimestampPattern());
        File target = new File(configFile.getAuditSchemaFileDir() + File.separator + configFile.getAuditSchemaFileName() + "".bkup_"" + writeTimestamp);
        FileChannel sourceChannel = null;
        FileChannel targetChannel = null;
        try {
            sourceChannel = new FileInputStream(lastAuditSchema).getChannel();
            targetChannel = new FileOutputStream(target).getChannel();
            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IO exception occurred while copying file"", e);
        } finally {
            if ((target != null) && (target.exists()) && (target.length() > 0)) {
                isBkupFileOK = true;
            }
            try {
                if (sourceChannel != null) {
                    sourceChannel.close();
                }
                if (targetChannel != null) {
                    targetChannel.close();
                }
            } catch (IOException e) {
                logger.info(""closing channels failed"");
            }
        }
        return isBkupFileOK;
    }
"
"    public static String getBiopaxId(Reaction reaction) {
        String id = null;
        if (reaction.getId() > Reaction.NO_ID_ASSIGNED) {
            id = reaction.getId().toString();
        } else {
            try {
                MessageDigest md = MessageDigest.getInstance(""MD5"");
                md.update(reaction.getTextualRepresentation().getBytes());
                byte[] digestBytes = md.digest();
                StringBuilder digesterSb = new StringBuilder(32);
                for (int i = 0; i < digestBytes.length; i++) {
                    int intValue = digestBytes[i] & 0xFF;
                    if (intValue < 0x10) digesterSb.append('0');
                    digesterSb.append(Integer.toHexString(intValue));
                }
                id = digesterSb.toString();
            } catch (NoSuchAlgorithmException e) {
            }
        }
        return id;
    }
","    public String md5(String password) {
        MessageDigest m = null;
        try {
            m = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException ex) {
        }
        m.update(password.getBytes(), 0, password.length());
        return new BigInteger(1, m.digest()).toString(16);
    }
"
"    protected static final void copyFile(String from, String to) throws SeleniumException {
        try {
            java.io.File fileFrom = new File(from);
            java.io.File fileTo = new File(to);
            FileReader in = new FileReader(fileFrom);
            FileWriter out = new FileWriter(fileTo);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (Exception e) {
            throw new SeleniumException(""Failed to copy new file : "" + from + "" to : "" + to, e);
        }
    }
","    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println(""\n"" + src + "": not an ACRNEMA stream!"");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println(""\n"" + src + "": contains UIDs!"" + "" => probable already DICOM - do not convert"");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println(""\n"" + src + "": mismatch pixel data length!"" + "" => do not convert"");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, ""MONOCHROME2"");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
"
"    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
","    private void createWikiPages(WikiContext context) throws PluginException {
        OntologyWikiPageName owpn = new OntologyWikiPageName(omemo.getFormDataAlias().toUpperCase(), omemo.getFormDataVersionDate());
        String wikiPageFullFileName = WikiPageName2FullFileName(context, owpn.toString());
        String rdfFileNameWithPath = getWorkDir(context) + File.separator + owpn.toFileName();
        FileOutputStream fos = null;
        FileInputStream fis = null;
        try {
            fos = new FileOutputStream(wikiPageFullFileName);
            fis = new FileInputStream(rdfFileNameWithPath);
            InfoExtractor infoe = new InfoExtractor(fis, omemo.getFormDataNS(), omemo.getFormDataOntLang());
            infoe.writePage(getWorkDir(context), owpn, Omemo.checksWikiPageName);
            fis.close();
            fos.close();
        } catch (Exception e) {
            log.error(""Can not read local rdf file or can not write wiki page"");
            throw new PluginException(""Error creating wiki pages. See logs"");
        }
    }
"
"    public static String digestString(String data, String algorithm) {
        String result = null;
        if (data != null) {
            try {
                MessageDigest _md = MessageDigest.getInstance(algorithm);
                _md.update(data.getBytes());
                byte[] _digest = _md.digest();
                String _ds;
                _ds = toHexString(_digest, 0, _digest.length);
                result = _ds;
            } catch (NoSuchAlgorithmException e) {
                result = null;
            }
        }
        return result;
    }
","    public static String encrypt(String text) throws NoSuchAlgorithmException {
        MessageDigest md;
        md = MessageDigest.getInstance(""MD5"");
        byte[] md5hash = new byte[32];
        try {
            md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        md5hash = md.digest();
        return convertToHex(md5hash);
    }
"
"    private void writeToFile(Body b, File mime4jFile) throws FileNotFoundException, IOException {
        if (b instanceof TextBody) {
            String charset = CharsetUtil.toJavaCharset(b.getParent().getCharset());
            if (charset == null) {
                charset = ""ISO8859-1"";
            }
            OutputStream out = new FileOutputStream(mime4jFile);
            IOUtils.copy(((TextBody) b).getReader(), out, charset);
        } else {
            OutputStream out = new FileOutputStream(mime4jFile);
            IOUtils.copy(((BinaryBody) b).getInputStream(), out);
        }
    }
","    private void output(HttpServletResponse resp, InputStream is, long length, String fileName) throws Exception {
        resp.reset();
        String mimeType = ""image/jpeg"";
        resp.setContentType(mimeType);
        resp.setContentLength((int) length);
        resp.setHeader(""Content-Disposition"", ""inline; filename=\"""" + fileName + ""\"""");
        resp.setHeader(""Cache-Control"", ""must-revalidate"");
        ServletOutputStream sout = resp.getOutputStream();
        IOUtils.copy(is, sout);
        sout.flush();
        resp.flushBuffer();
    }
"
"    public static void unzipAndRemove(final String file) {
        String destination = file.substring(0, file.length() - 3);
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new GZIPInputStream(new FileInputStream(file));
            os = new FileOutputStream(destination);
            byte[] buffer = new byte[8192];
            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);
        } catch (IOException e) {
            System.err.println(""Fehler: Kann nicht entpacken "" + file);
        } finally {
            if (os != null) try {
                os.close();
            } catch (IOException e) {
            }
            if (is != null) try {
                is.close();
            } catch (IOException e) {
            }
        }
        deleteFile(file);
    }
","    public static void copyFile(File src, File dest) throws IOException {
        FileInputStream fIn;
        FileOutputStream fOut;
        FileChannel fIChan, fOChan;
        long fSize;
        MappedByteBuffer mBuf;
        fIn = new FileInputStream(src);
        fOut = new FileOutputStream(dest);
        fIChan = fIn.getChannel();
        fOChan = fOut.getChannel();
        fSize = fIChan.size();
        mBuf = fIChan.map(FileChannel.MapMode.READ_ONLY, 0, fSize);
        fOChan.write(mBuf);
        fIChan.close();
        fIn.close();
        fOChan.close();
        fOut.close();
    }
"
"    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(""image/png"");
        OutputStream outStream;
        outStream = resp.getOutputStream();
        InputStream is;
        String name = req.getParameter(""name"");
        if (name == null) {
            is = ImageServlet.class.getResourceAsStream(""/com/actionbazaar/blank.png"");
        } else {
            ImageRecord imageRecord = imageBean.getFile(name);
            if (imageRecord != null) {
                is = new BufferedInputStream(new FileInputStream(imageRecord.getThumbnailFile()));
            } else {
                is = ImageServlet.class.getResourceAsStream(""/com/actionbazaar/blank.png"");
            }
        }
        IOUtils.copy(is, outStream);
        outStream.close();
        outStream.flush();
    }
","    private void copy(File inputFile, File outputFile) {
        BufferedReader reader = null;
        BufferedWriter writer = null;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), ""UTF-8""));
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile), ""UTF-8""));
            while (reader.ready()) {
                writer.write(reader.readLine());
                writer.write(System.getProperty(""line.separator""));
            }
        } catch (IOException e) {
        } finally {
            try {
                if (reader != null) reader.close();
                if (writer != null) writer.close();
            } catch (IOException e1) {
            }
        }
    }
"
"    public static String encryptPassword(String originalPassword) {
        if (!StringUtils.hasText(originalPassword)) {
            originalPassword = randomPassword();
        }
        try {
            MessageDigest md5 = MessageDigest.getInstance(PASSWORD_ENCRYPTION_TYPE);
            md5.update(originalPassword.getBytes());
            byte[] bytes = md5.digest();
            int value;
            StringBuilder buf = new StringBuilder();
            for (byte aByte : bytes) {
                value = aByte;
                if (value < 0) {
                    value += 256;
                }
                if (value < 16) {
                    buf.append(""0"");
                }
                buf.append(Integer.toHexString(value));
            }
            return buf.toString();
        } catch (NoSuchAlgorithmException e) {
            log.debug(""Do not encrypt password,use original password"", e);
            return originalPassword;
        }
    }
","    private String getBytes(String in) throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance(""MD5"");
        md5.update(in.getBytes());
        byte[] passWordBytes = md5.digest();
        String s = ""["";
        for (int i = 0; i < passWordBytes.length; i++) s += passWordBytes[i] + "", "";
        s = s.substring(0, s.length() - 2);
        s += ""]"";
        return s;
    }
"
"    public static void copyFile(File in, File out) throws IOException {
        try {
            FileReader inf = new FileReader(in);
            OutputStreamWriter outf = new OutputStreamWriter(new FileOutputStream(out), ""UTF-8"");
            int c;
            while ((c = inf.read()) != -1) outf.write(c);
            inf.close();
            outf.close();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
","    public static void copy(File source, File dest) throws java.io.IOException {
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
"
"    public static Document convertHtmlToXml(final InputStream htmlInputStream, final String classpathXsltResource, final String encoding) {
        Parser p = new Parser();
        javax.xml.parsers.DocumentBuilder db;
        try {
            db = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            log.error("""", e);
            throw new RuntimeException();
        }
        Document document = db.newDocument();
        InputStream is = htmlInputStream;
        if (log.isDebugEnabled()) {
            ByteArrayOutputStream baos;
            baos = new ByteArrayOutputStream();
            try {
                IOUtils.copy(is, baos);
            } catch (IOException e) {
                log.error(""Fail to make input stream copy."", e);
            }
            IOUtils.closeQuietly(is);
            ByteArrayInputStream byteArrayInputStream;
            byteArrayInputStream = new ByteArrayInputStream(baos.toByteArray());
            try {
                IOUtils.toString(new ByteArrayInputStream(baos.toByteArray()), ""UTF-8"");
            } catch (IOException e) {
                log.error("""", e);
            }
            IOUtils.closeQuietly(byteArrayInputStream);
            is = new ByteArrayInputStream(baos.toByteArray());
        }
        try {
            InputSource iSource = new InputSource(is);
            iSource.setEncoding(encoding);
            Source transformerSource = new SAXSource(p, iSource);
            Result result = new DOMResult(document);
            Transformer xslTransformer = getTransformerByName(classpathXsltResource, false);
            try {
                xslTransformer.transform(transformerSource, result);
            } catch (TransformerException e) {
                throw new RuntimeException(e);
            }
        } finally {
            try {
                is.close();
            } catch (Exception e) {
                log.warn("""", e);
            }
        }
        return document;
    }
","    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    public static String getKeyWithRightLength(final String key, int keyLength) {
        if (keyLength > 0) {
            if (key.length() == keyLength) {
                return key;
            } else {
                MessageDigest md = null;
                try {
                    md = MessageDigest.getInstance(""SHA-1"");
                } catch (NoSuchAlgorithmException e) {
                    return """";
                }
                md.update(key.getBytes());
                byte[] hash = md.digest();
                if (keyLength > 20) {
                    byte nhash[] = new byte[keyLength];
                    for (int i = 0; i < keyLength; i++) {
                        nhash[i] = hash[i % 20];
                    }
                    hash = nhash;
                }
                return new String(hash).substring(0, keyLength);
            }
        } else {
            return key;
        }
    }
","        public static String digest(String password) {
            try {
                byte[] digest;
                synchronized (__md5Lock) {
                    if (__md == null) {
                        try {
                            __md = MessageDigest.getInstance(""MD5"");
                        } catch (Exception e) {
                            Log.warn(e);
                            return null;
                        }
                    }
                    __md.reset();
                    __md.update(password.getBytes(StringUtil.__ISO_8859_1));
                    digest = __md.digest();
                }
                return __TYPE + TypeUtil.toString(digest, 16);
            } catch (Exception e) {
                Log.warn(e);
                return null;
            }
        }
"
"    private static void copy(String from_name, String to_name) throws IOException {
        File from_file = new File(from_name);
        File to_file = new File(to_name);
        if (!from_file.exists()) abort(""�������� ���� �� ���������"" + from_file);
        if (!from_file.isFile()) abort(""���������� ����������� ��������"" + from_file);
        if (!from_file.canRead()) abort(""�������� ���� ���������� ��� ������"" + from_file);
        if (from_file.isDirectory()) to_file = new File(to_file, from_file.getName());
        if (to_file.exists()) {
            if (!to_file.canWrite()) abort(""�������� ���� ���������� ��� ������"" + to_file);
            System.out.println(""������������ ������� ����?"" + to_file.getName() + ""?(Y/N):"");
            System.out.flush();
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            String response = in.readLine();
            if (!response.equals(""Y"") && !response.equals(""y"")) abort(""������������ ���� �� ��� �����������"");
        } else {
            String parent = to_file.getParent();
            if (parent == null) parent = System.getProperty(""user.dir"");
            File dir = new File(parent);
            if (!dir.exists()) abort(""������� ���������� �� ���������"" + parent);
            if (!dir.isFile()) abort(""�� �������� ���������"" + parent);
            if (!dir.canWrite()) abort(""������ �� ������"" + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(from_file);
            to = new FileOutputStream(to_file);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
","    JcrFile createBody(Part part) throws IOException, MessagingException {
        JcrFile body = new JcrFile();
        body.setName(""part"");
        ByteArrayOutputStream pout = new ByteArrayOutputStream();
        IOUtils.copy(part.getInputStream(), pout);
        body.setDataProvider(new JcrDataProviderImpl(TYPE.BYTES, pout.toByteArray()));
        body.setMimeType(part.getContentType());
        body.setLastModified(java.util.Calendar.getInstance());
        return body;
    }
"
"    private static void downloadFile(URL url, File destFile) throws Exception {
        try {
            URLConnection urlConnection = url.openConnection();
            File tmpFile = null;
            try {
                tmpFile = File.createTempFile(""remoteLib_"", null);
                InputStream in = null;
                FileOutputStream out = null;
                try {
                    in = urlConnection.getInputStream();
                    out = new FileOutputStream(tmpFile);
                    IOUtils.copy(in, out);
                } finally {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                }
                FileUtils.copyFile(tmpFile, destFile);
            } finally {
                if (tmpFile != null) {
                    tmpFile.delete();
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(""Could not download URL: "" + url, ex);
        }
    }
","    private static void copyFile(File srcFile, File destFile, long chunkSize) throws IOException {
        FileInputStream is = null;
        FileOutputStream os = null;
        try {
            is = new FileInputStream(srcFile);
            FileChannel iChannel = is.getChannel();
            os = new FileOutputStream(destFile, false);
            FileChannel oChannel = os.getChannel();
            long doneBytes = 0L;
            long todoBytes = srcFile.length();
            while (todoBytes != 0L) {
                long iterationBytes = Math.min(todoBytes, chunkSize);
                long transferredLength = oChannel.transferFrom(iChannel, doneBytes, iterationBytes);
                if (iterationBytes != transferredLength) {
                    throw new IOException(""Error during file transfer: expected "" + iterationBytes + "" bytes, only "" + transferredLength + "" bytes copied."");
                }
                doneBytes += transferredLength;
                todoBytes -= transferredLength;
            }
        } finally {
            if (is != null) {
                is.close();
            }
            if (os != null) {
                os.close();
            }
        }
        boolean successTimestampOp = destFile.setLastModified(srcFile.lastModified());
        if (!successTimestampOp) {
            log.warn(""Could not change timestamp for {}. Index synchronization may be slow."", destFile);
        }
    }
"
"    public void removeExifTag(File jpegImageFile, File dst) throws IOException, ImageReadException, ImageWriteException {
        OutputStream os = null;
        try {
            TiffOutputSet outputSet = null;
            IImageMetadata metadata = Sanselan.getMetadata(jpegImageFile);
            JpegImageMetadata jpegMetadata = (JpegImageMetadata) metadata;
            if (null != jpegMetadata) {
                TiffImageMetadata exif = jpegMetadata.getExif();
                if (null != exif) {
                    outputSet = exif.getOutputSet();
                }
            }
            if (null == outputSet) {
                IOUtils.copyFileNio(jpegImageFile, dst);
                return;
            }
            {
                outputSet.removeField(TiffConstants.EXIF_TAG_APERTURE_VALUE);
                TiffOutputDirectory exifDirectory = outputSet.getExifDirectory();
                if (null != exifDirectory) exifDirectory.removeField(TiffConstants.EXIF_TAG_APERTURE_VALUE);
            }
            os = new FileOutputStream(dst);
            os = new BufferedOutputStream(os);
            new ExifRewriter().updateExifMetadataLossless(jpegImageFile, os, outputSet);
            os.close();
            os = null;
        } finally {
            if (os != null) try {
                os.close();
            } catch (IOException e) {
            }
        }
    }
","    public void copyFile(File s, File t) {
        try {
            FileChannel in = (new FileInputStream(s)).getChannel();
            FileChannel out = (new FileOutputStream(t)).getChannel();
            in.transferTo(0, s.length(), out);
            in.close();
            out.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
"
"    public ODFSignatureService(TimeStampServiceValidator timeStampServiceValidator, RevocationDataService revocationDataService, SignatureFacet signatureFacet, InputStream documentInputStream, OutputStream documentOutputStream, TimeStampService timeStampService, String role, IdentityDTO identity, byte[] photo, DigestAlgo digestAlgo) throws Exception {
        super(digestAlgo);
        this.temporaryDataStorage = new HttpSessionTemporaryDataStorage();
        this.documentOutputStream = documentOutputStream;
        this.tmpFile = File.createTempFile(""eid-dss-"", "".odf"");
        FileOutputStream fileOutputStream;
        fileOutputStream = new FileOutputStream(this.tmpFile);
        IOUtils.copy(documentInputStream, fileOutputStream);
        addSignatureFacet(new XAdESXLSignatureFacet(timeStampService, revocationDataService, getSignatureDigestAlgorithm()));
        addSignatureFacet(signatureFacet);
        XAdESSignatureFacet xadesSignatureFacet = super.getXAdESSignatureFacet();
        xadesSignatureFacet.setRole(role);
        if (null != identity) {
            IdentitySignatureFacet identitySignatureFacet = new IdentitySignatureFacet(identity, photo, getSignatureDigestAlgorithm());
            addSignatureFacet(identitySignatureFacet);
        }
    }
","    @NotNull
    private Properties loadProperties() {
        File file = new File(homeLocator.getHomeDir(), configFilename);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                throw new RuntimeException(""IOException while creating \"""" + file.getAbsolutePath() + ""\""."", e);
            }
        }
        if (!file.canRead() || !file.canWrite()) {
            throw new RuntimeException(""Cannot read and write from file: "" + file.getAbsolutePath());
        }
        if (lastModifiedByUs < file.lastModified()) {
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""File \"""" + file + ""\"" is newer on disk. Read it ..."");
            }
            Properties properties = new Properties();
            try {
                FileInputStream in = new FileInputStream(file);
                try {
                    properties.loadFromXML(in);
                } catch (InvalidPropertiesFormatException e) {
                    FileOutputStream out = new FileOutputStream(file);
                    try {
                        properties.storeToXML(out, comment);
                    } finally {
                        out.close();
                    }
                } finally {
                    in.close();
                }
            } catch (IOException e) {
                throw new RuntimeException(""IOException while reading from \"""" + file.getAbsolutePath() + ""\""."", e);
            }
            this.lastModifiedByUs = file.lastModified();
            this.properties = properties;
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""... read done."");
            }
        }
        assert this.properties != null;
        return this.properties;
    }
"
"    public static Set<Province> getProvincias(String pURL) {
        Set<Province> result = new HashSet<Province>();
        String iniProv = ""<prov>"";
        String finProv = ""</prov>"";
        String iniNomProv = ""<np>"";
        String finNomProv = ""</np>"";
        String iniCodigo = ""<cpine>"";
        String finCodigo = ""</cpine>"";
        int ini, fin;
        try {
            URL url = new URL(pURL);
            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
            String str;
            Province provincia;
            while ((str = br.readLine()) != null) {
                if (str.contains(iniProv)) {
                    provincia = new Province();
                    while ((str = br.readLine()) != null && !str.contains(finProv)) {
                        if (str.contains(iniNomProv)) {
                            ini = str.indexOf(iniNomProv) + iniNomProv.length();
                            fin = str.indexOf(finNomProv);
                            provincia.setDescription(str.substring(ini, fin));
                        }
                        if (str.contains(iniCodigo)) {
                            ini = str.indexOf(iniCodigo) + iniCodigo.length();
                            fin = str.indexOf(finCodigo);
                            provincia.setCodeProvince(Integer.parseInt(str.substring(ini, fin)));
                        }
                    }
                    result.add(provincia);
                }
            }
            br.close();
        } catch (Exception e) {
            System.err.println(e);
        }
        return result;
    }
","    @SuppressWarnings(""unchecked"")
    private List<String> getWordList() {
        IConfiguration config = Configurator.getDefaultConfigurator().getConfig(CONFIG_ID);
        List<String> wList = (List<String>) config.getObject(""word_list"");
        if (wList == null) {
            wList = new ArrayList<String>();
            InputStream resrc = null;
            try {
                resrc = new URL(list_url).openStream();
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (resrc != null) {
                BufferedReader br = new BufferedReader(new InputStreamReader(resrc));
                String line;
                try {
                    while ((line = br.readLine()) != null) {
                        line = line.trim();
                        if (line.length() != 0) {
                            wList.add(line);
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    if (br != null) {
                        try {
                            br.close();
                        } catch (IOException e) {
                        }
                    }
                }
            }
        }
        return wList;
    }
"
"    public static Document convertHtmlToXml(final InputStream htmlInputStream, final String classpathXsltResource, final String encoding) {
        Parser p = new Parser();
        javax.xml.parsers.DocumentBuilder db;
        try {
            db = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            log.error("""", e);
            throw new RuntimeException();
        }
        Document document = db.newDocument();
        InputStream is = htmlInputStream;
        if (log.isDebugEnabled()) {
            ByteArrayOutputStream baos;
            baos = new ByteArrayOutputStream();
            try {
                IOUtils.copy(is, baos);
            } catch (IOException e) {
                log.error(""Fail to make input stream copy."", e);
            }
            IOUtils.closeQuietly(is);
            ByteArrayInputStream byteArrayInputStream;
            byteArrayInputStream = new ByteArrayInputStream(baos.toByteArray());
            try {
                IOUtils.toString(new ByteArrayInputStream(baos.toByteArray()), ""UTF-8"");
            } catch (IOException e) {
                log.error("""", e);
            }
            IOUtils.closeQuietly(byteArrayInputStream);
            is = new ByteArrayInputStream(baos.toByteArray());
        }
        try {
            InputSource iSource = new InputSource(is);
            iSource.setEncoding(encoding);
            Source transformerSource = new SAXSource(p, iSource);
            Result result = new DOMResult(document);
            Transformer xslTransformer = getTransformerByName(classpathXsltResource, false);
            try {
                xslTransformer.transform(transformerSource, result);
            } catch (TransformerException e) {
                throw new RuntimeException(e);
            }
        } finally {
            try {
                is.close();
            } catch (Exception e) {
                log.warn("""", e);
            }
        }
        return document;
    }
","    private void externalizeFiles(Document doc, File out) throws IOException {
        File[] files = doc.getImages();
        if (files.length > 0) {
            File dir = new File(out.getParentFile(), out.getName() + "".images"");
            if (!dir.mkdirs()) throw new IOException(""cannot create directory "" + dir);
            if (dir.exists()) {
                for (int i = 0; i < files.length; i++) {
                    File file = files[i];
                    File copy = new File(dir, file.getName());
                    FileChannel from = null, to = null;
                    long count = -1;
                    try {
                        from = new FileInputStream(file).getChannel();
                        count = from.size();
                        to = new FileOutputStream(copy).getChannel();
                        from.transferTo(0, count, to);
                        doc.setImage(file, dir.getName() + ""/"" + copy.getName());
                    } catch (Throwable t) {
                        LOG.log(Level.WARNING, ""Copying '"" + file + ""' to '"" + copy + ""' failed (size="" + count + "")"", t);
                    } finally {
                        try {
                            to.close();
                        } catch (Throwable t) {
                        }
                        try {
                            from.close();
                        } catch (Throwable t) {
                        }
                    }
                }
            }
        }
    }
"
"    private byte[] streamToBytes(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try {
            IOUtils.copy(in, out);
        } finally {
            IOUtils.closeQuietly(in);
        }
        return out.toByteArray();
    }
","    public static void copyFile(File inputFile, File outputFile) throws IOException {
        FileChannel srcChannel = new FileInputStream(inputFile).getChannel();
        FileChannel dstChannel = new FileOutputStream(outputFile).getChannel();
        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
        srcChannel.close();
        dstChannel.close();
    }
"
"    private void copy(String imgPath, String path) {
        try {
            File input = new File(imgPath);
            File output = new File(path, input.getName());
            if (output.exists()) {
                if (!MessageDialog.openQuestion(getShell(), ""Overwrite"", ""There is already an image file "" + input.getName() + "" under the package.\n Do you really want to overwrite it?"")) return;
            }
            byte[] data = new byte[1024];
            FileInputStream fis = new FileInputStream(imgPath);
            BufferedInputStream bis = new BufferedInputStream(fis);
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(output));
            int length;
            while ((length = bis.read(data)) > 0) {
                bos.write(data, 0, length);
                bos.flush();
            }
            bos.close();
            fis.close();
            IJavaProject ijp = VisualSwingPlugin.getCurrentProject();
            if (ijp != null) {
                ijp.getProject().refreshLocal(IResource.DEPTH_INFINITE, null);
                view.refresh();
                view.expandAll();
            }
        } catch (Exception e) {
            VisualSwingPlugin.getLogger().error(e);
        }
    }
","    public static void compress(final File zip, final Map<InputStream, String> entries) throws IOException {
        if (zip == null || entries == null || CollectionUtils.isEmpty(entries.keySet())) throw new IllegalArgumentException(""One ore more parameters are empty!"");
        if (zip.exists()) zip.delete(); else if (!zip.getParentFile().exists()) zip.getParentFile().mkdirs();
        ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zip)));
        out.setLevel(Deflater.BEST_COMPRESSION);
        InputStream in = null;
        try {
            for (InputStream inputStream : entries.keySet()) {
                in = inputStream;
                ZipEntry zipEntry = new ZipEntry(skipBeginningSlash(entries.get(in)));
                out.putNextEntry(zipEntry);
                IOUtils.copy(in, out);
                out.closeEntry();
                in.close();
            }
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
"
"    public static void copy(File src, File dest) throws IOException {
        OutputStream stream = new FileOutputStream(dest);
        FileInputStream fis = new FileInputStream(src);
        byte[] buffer = new byte[16384];
        while (fis.available() != 0) {
            int read = fis.read(buffer);
            stream.write(buffer, 0, read);
        }
        stream.flush();
    }
","    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    public static void copyFile(File source, File dest) throws IOException {
        if (source.equals(dest)) throw new IOException(""Source and destination cannot be the same file path"");
        FileChannel srcChannel = new FileInputStream(source).getChannel();
        if (!dest.exists()) dest.createNewFile();
        FileChannel dstChannel = new FileOutputStream(dest).getChannel();
        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
        srcChannel.close();
        dstChannel.close();
    }
","    private static void copy(File src, File dst) {
        try {
            FileChannel srcChannel = new FileInputStream(src).getChannel();
            FileChannel dstChannel = new FileOutputStream(dst).getChannel();
            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            srcChannel.close();
            dstChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
"    static void conditionalCopyFile(File dst, File src) throws IOException {
        if (dst.equals(src)) return;
        if (!dst.isFile() || dst.lastModified() < src.lastModified()) {
            System.out.println(""Copying "" + src);
            InputStream is = new FileInputStream(src);
            OutputStream os = new FileOutputStream(dst);
            byte[] buf = new byte[8192];
            int len;
            while ((len = is.read(buf)) > 0) os.write(buf, 0, len);
            os.close();
            is.close();
        }
    }
","    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
"
"    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println(""reading "" + inFile + ""..."");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println(""writing "" + outFile + ""..."");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println(""done!"");
    }
","    private String createDefaultRepoConf() throws IOException {
        InputStream confIn = getClass().getResourceAsStream(REPO_CONF_PATH);
        File tempConfFile = File.createTempFile(""repository"", ""xml"");
        tempConfFile.deleteOnExit();
        IOUtils.copy(confIn, new FileOutputStream(tempConfFile));
        return tempConfFile.getAbsolutePath();
    }
"
"    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
","    public static void copyFile(File sourceFile, File targetFile) throws IOException {
        if (sourceFile == null || targetFile == null) {
            throw new NullPointerException(""Source file and target file must not be null"");
        }
        File directory = targetFile.getParentFile();
        if (!directory.exists() && !directory.mkdirs()) {
            throw new IOException(""Could not create directory '"" + directory + ""'"");
        }
        InputStream inputStream = null;
        OutputStream outputStream = null;
        try {
            inputStream = new BufferedInputStream(new FileInputStream(sourceFile));
            outputStream = new BufferedOutputStream(new FileOutputStream(targetFile));
            try {
                byte[] buffer = new byte[32768];
                for (int readBytes = inputStream.read(buffer); readBytes > 0; readBytes = inputStream.read(buffer)) {
                    outputStream.write(buffer, 0, readBytes);
                }
            } catch (IOException ex) {
                targetFile.delete();
                throw ex;
            }
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException ex) {
                }
            }
            if (outputStream != null) {
                try {
                    outputStream.close();
                } catch (IOException ex) {
                }
            }
        }
    }
"
"    public static void copyFile(File source, File dest) throws IOException {
        if (source.equals(dest)) throw new IOException(""Source and destination cannot be the same file path"");
        FileChannel srcChannel = new FileInputStream(source).getChannel();
        if (!dest.exists()) dest.createNewFile();
        FileChannel dstChannel = new FileOutputStream(dest).getChannel();
        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
        srcChannel.close();
        dstChannel.close();
    }
","    public static void copyFile(String input, String output) {
        try {
            FileChannel srcChannel = new FileInputStream(""srcFilename"").getChannel();
            FileChannel dstChannel = new FileOutputStream(""dstFilename"").getChannel();
            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            srcChannel.close();
            dstChannel.close();
        } catch (IOException e) {
        }
    }
"
"    @Test
    public void testWriteAndReadBiggerUnbuffered() throws Exception {
        JCFSFileServer server = new JCFSFileServer(defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);
        JCFS.configureDiscovery(defaultUdpAddress, defaultUdpPort);
        try {
            server.start();
            RFile file = new RFile(""testreadwriteb.txt"");
            RFileOutputStream out = new RFileOutputStream(file);
            String body = """";
            int size = 50 * 1024;
            for (int i = 0; i < size; i++) {
                body = body + ""a"";
            }
            out.write(body.getBytes(""utf-8""));
            out.close();
            File expected = new File(dir, ""testreadwriteb.txt"");
            assertTrue(expected.isFile());
            assertEquals(body.length(), expected.length());
            RFileInputStream in = new RFileInputStream(file);
            ByteArrayOutputStream tmp = new ByteArrayOutputStream();
            int b = in.read();
            while (b != -1) {
                tmp.write(b);
                b = in.read();
            }
            byte[] buffer = tmp.toByteArray();
            in.close();
            assertEquals(body.length(), buffer.length);
            String resultRead = new String(buffer, ""utf-8"");
            assertEquals(body, resultRead);
        } finally {
            server.stop();
        }
    }
","    public static boolean copyFileCover(String srcFileName, String descFileName, boolean coverlay) {
        File srcFile = new File(srcFileName);
        if (!srcFile.exists()) {
            System.out.println(""复制文件失败，源文件"" + srcFileName + ""不存在!"");
            return false;
        } else if (!srcFile.isFile()) {
            System.out.println(""复制文件失败，"" + srcFileName + ""不是一个文件!"");
            return false;
        }
        File descFile = new File(descFileName);
        if (descFile.exists()) {
            if (coverlay) {
                System.out.println(""目标文件已存在，准备删除!"");
                if (!FileOperateUtils.delFile(descFileName)) {
                    System.out.println(""删除目标文件"" + descFileName + ""失败!"");
                    return false;
                }
            } else {
                System.out.println(""复制文件失败，目标文件"" + descFileName + ""已存在!"");
                return false;
            }
        } else {
            if (!descFile.getParentFile().exists()) {
                System.out.println(""目标文件所在的目录不存在，创建目录!"");
                if (!descFile.getParentFile().mkdirs()) {
                    System.out.println(""创建目标文件所在的目录失败!"");
                    return false;
                }
            }
        }
        int readByte = 0;
        InputStream ins = null;
        OutputStream outs = null;
        try {
            ins = new FileInputStream(srcFile);
            outs = new FileOutputStream(descFile);
            byte[] buf = new byte[1024];
            while ((readByte = ins.read(buf)) != -1) {
                outs.write(buf, 0, readByte);
            }
            System.out.println(""复制单个文件"" + srcFileName + ""到"" + descFileName + ""成功!"");
            return true;
        } catch (Exception e) {
            System.out.println(""复制文件失败："" + e.getMessage());
            return false;
        } finally {
            if (outs != null) {
                try {
                    outs.close();
                } catch (IOException oute) {
                    oute.printStackTrace();
                }
            }
            if (ins != null) {
                try {
                    ins.close();
                } catch (IOException ine) {
                    ine.printStackTrace();
                }
            }
        }
    }
"
"    private void copyFile(File sourceFile, File destFile) throws IOException {
        if (log.isDebugEnabled()) {
            log.debug(""CopyFile : Source["" + sourceFile.getAbsolutePath() + ""] Dest["" + destFile.getAbsolutePath() + ""]"");
        }
        if (!destFile.exists()) {
            destFile.createNewFile();
        }
        FileChannel source = null;
        FileChannel destination = null;
        try {
            source = new FileInputStream(sourceFile).getChannel();
            destination = new FileOutputStream(destFile).getChannel();
            destination.transferFrom(source, 0, source.size());
        } finally {
            if (source != null) {
                source.close();
            }
            if (destination != null) {
                destination.close();
            }
        }
    }
","    private void copy(final File src, final File dstDir) {
        dstDir.mkdirs();
        final File dst = new File(dstDir, src.getName());
        BufferedReader reader = null;
        BufferedWriter writer = null;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(src), ""ISO-8859-1""));
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dst), ""ISO-8859-1""));
            String read;
            while ((read = reader.readLine()) != null) {
                Line line = new Line(read);
                if (line.isComment()) continue;
                writer.write(read);
                writer.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) try {
                reader.close();
            } catch (IOException e) {
            }
            if (writer != null) {
                try {
                    writer.flush();
                } catch (IOException e) {
                }
                try {
                    writer.close();
                } catch (IOException e) {
                }
            }
        }
    }
"
"    public static void copy(String srcFileName, String destFileName) throws IOException {
        if (srcFileName == null) {
            throw new IllegalArgumentException(""srcFileName is null"");
        }
        if (destFileName == null) {
            throw new IllegalArgumentException(""destFileName is null"");
        }
        FileChannel src = null;
        FileChannel dest = null;
        try {
            src = new FileInputStream(srcFileName).getChannel();
            dest = new FileOutputStream(destFileName).getChannel();
            long n = src.size();
            MappedByteBuffer buf = src.map(FileChannel.MapMode.READ_ONLY, 0, n);
            dest.write(buf);
        } finally {
            if (dest != null) {
                try {
                    dest.close();
                } catch (IOException e1) {
                }
            }
            if (src != null) {
                try {
                    src.close();
                } catch (IOException e1) {
                }
            }
        }
    }
","    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile(""diff"", "".htm"");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write(""<html><head><title>LOC Differences</title>\n"" + SCRIPT + ""</head>\n"" + ""<body bgcolor='#ffffff'>\n"" + ""<div onMouseOver=\""window.defaultStatus='Metrics'\"">\n"");
        if (addedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Added:</th>"" + ""<th>Add</th><th>Type</th></tr>"");
            out.write(addedTable.toString());
            out.write(""</table><br><br>"");
        }
        if (modifiedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Modified:</th>"" + ""<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>"" + ""<th>Total</th><th>Type</th></tr>"");
            out.write(modifiedTable.toString());
            out.write(""</table><br><br>"");
        }
        if (deletedTable.length() > 0) {
            out.write(""<table border><tr><th>Files Deleted:</th>"" + ""<th>Del</th><th>Type</th></tr>"");
            out.write(deletedTable.toString());
            out.write(""</table><br><br>"");
        }
        out.write(""<table name=METRICS BORDER>\n"");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write(""<tr><td>Base:&nbsp;</td><td>"");
            out.write(Long.toString(base));
            out.write(""</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>"");
            out.write(Long.toString(deleted));
            out.write(""</td></tr>\n<tr><td>Modified:&nbsp;</td><td>"");
            out.write(Long.toString(modified));
            out.write(""</td></tr>\n<tr><td>Added:&nbsp;</td><td>"");
            out.write(Long.toString(added));
            out.write(""</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>"");
            out.write(Long.toString(added + modified));
            out.write(""</td></tr>\n"");
        }
        out.write(""<tr><td>Total:&nbsp;</td><td>"");
        out.write(Long.toString(total));
        out.write(""</td></tr>\n</table></div>"");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write(""</BODY></HTML>"".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
"
"    public static boolean copyFile(String fileIn, String fileOut) {
        FileChannel in = null;
        FileChannel out = null;
        boolean retour = false;
        try {
            in = new FileInputStream(fileIn).getChannel();
            out = new FileOutputStream(fileOut).getChannel();
            in.transferTo(0, in.size(), out);
            in.close();
            out.close();
            retour = true;
        } catch (IOException e) {
            System.err.println(""File : "" + fileIn);
            e.printStackTrace();
        }
        return retour;
    }
","    protected static String getFileContentAsString(URL url, String encoding) throws IOException {
        InputStream input = null;
        StringWriter sw = new StringWriter();
        try {
            System.out.println(""Free mem :"" + Runtime.getRuntime().freeMemory());
            input = url.openStream();
            IOUtils.copy(input, sw, encoding);
            System.out.println(""Free mem :"" + Runtime.getRuntime().freeMemory());
        } finally {
            if (input != null) {
                input.close();
                System.gc();
                input = null;
                System.out.println(""Free mem :"" + Runtime.getRuntime().freeMemory());
            }
        }
        return sw.toString();
    }
"
"    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println(""\n"" + src + "": not an ACRNEMA stream!"");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println(""\n"" + src + "": contains UIDs!"" + "" => probable already DICOM - do not convert"");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println(""\n"" + src + "": mismatch pixel data length!"" + "" => do not convert"");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, ""MONOCHROME2"");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
","    public void jsFunction_extract(ScriptableFile outputFile) throws IOException, FileSystemException, ArchiveException {
        InputStream is = file.jsFunction_createInputStream();
        OutputStream output = outputFile.jsFunction_createOutputStream();
        BufferedInputStream buf = new BufferedInputStream(is);
        ArchiveInputStream input = ScriptableZipArchive.getFactory().createArchiveInputStream(buf);
        try {
            long count = 0;
            while (input.getNextEntry() != null) {
                if (count == offset) {
                    IOUtils.copy(input, output);
                    break;
                }
                count++;
            }
        } finally {
            input.close();
            output.close();
            is.close();
        }
    }
"
"    public void copyFileFromLocalMachineToRemoteMachine(InputStream source, File destination) throws Exception {
        String fileName = destination.getPath();
        File f = new File(getFtpServerHome(), """" + System.currentTimeMillis());
        f.deleteOnExit();
        org.apache.commons.io.IOUtils.copy(source, new FileOutputStream(f));
        remoteHostClient.setAscii(isAscii());
        remoteHostClient.setPromptOn(isPrompt());
        remoteHostClient.copyFileFromLocalMachineToRemoteClient(f.getName(), fileName);
    }
","    public static void copieFichier(File fichier1, File fichier2) {
        FileChannel in = null;
        FileChannel out = null;
        try {
            in = new FileInputStream(fichier1).getChannel();
            out = new FileOutputStream(fichier2).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                }
            }
        }
    }
"
"    private static void insertModuleInEar(File fromEar, File toEar, String moduleType, String moduleName, String contextRoot) throws Exception {
        ZipInputStream earFile = new ZipInputStream(new FileInputStream(fromEar));
        FileOutputStream fos = new FileOutputStream(toEar);
        ZipOutputStream tempZip = new ZipOutputStream(fos);
        ZipEntry next = earFile.getNextEntry();
        while (next != null) {
            ByteArrayOutputStream content = new ByteArrayOutputStream();
            byte[] data = new byte[30000];
            int numberread;
            while ((numberread = earFile.read(data)) != -1) {
                content.write(data, 0, numberread);
            }
            if (next.getName().equals(""META-INF/application.xml"")) {
                content = insertModule(earFile, next, content, moduleType, moduleName, contextRoot);
                next = new ZipEntry(""META-INF/application.xml"");
            }
            tempZip.putNextEntry(next);
            tempZip.write(content.toByteArray());
            next = earFile.getNextEntry();
        }
        earFile.close();
        tempZip.close();
        fos.close();
    }
","    public void copyFileToFileWithPaths(String sourcePath, String destinPath) throws Exception {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        byte dataBuff[] = new byte[bufferSize];
        File file1 = new File(sourcePath);
        if (file1.exists() && (file1.isFile())) {
            File file2 = new File(destinPath);
            if (file2.exists()) {
                file2.delete();
            }
            FileUtils.getInstance().createDirectory(file2.getParent());
            in = new BufferedInputStream(new FileInputStream(sourcePath), bufferSize);
            out = new BufferedOutputStream(new FileOutputStream(destinPath), bufferSize);
            int readLen;
            while ((readLen = in.read(dataBuff)) > 0) {
                out.write(dataBuff, 0, readLen);
            }
            out.flush();
            in.close();
            out.close();
        } else {
            throw new Exception(""Source file not exist ! sourcePath = ("" + sourcePath + "")"");
        }
    }
"
"    public static void main(String argv[]) {
        Matrix A, B, C, Z, O, I, R, S, X, SUB, M, T, SQ, DEF, SOL;
        int errorCount = 0;
        int warningCount = 0;
        double tmp, s;
        double[] columnwise = { 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12. };
        double[] rowwise = { 1., 4., 7., 10., 2., 5., 8., 11., 3., 6., 9., 12. };
        double[][] avals = { { 1., 4., 7., 10. }, { 2., 5., 8., 11. }, { 3., 6., 9., 12. } };
        double[][] rankdef = avals;
        double[][] tvals = { { 1., 2., 3. }, { 4., 5., 6. }, { 7., 8., 9. }, { 10., 11., 12. } };
        double[][] subavals = { { 5., 8., 11. }, { 6., 9., 12. } };
        double[][] rvals = { { 1., 4., 7. }, { 2., 5., 8., 11. }, { 3., 6., 9., 12. } };
        double[][] pvals = { { 1., 1., 1. }, { 1., 2., 3. }, { 1., 3., 6. } };
        double[][] ivals = { { 1., 0., 0., 0. }, { 0., 1., 0., 0. }, { 0., 0., 1., 0. } };
        double[][] evals = { { 0., 1., 0., 0. }, { 1., 0., 2.e-7, 0. }, { 0., -2.e-7, 0., 1. }, { 0., 0., 1., 0. } };
        double[][] square = { { 166., 188., 210. }, { 188., 214., 240. }, { 210., 240., 270. } };
        double[][] sqSolution = { { 13. }, { 15. } };
        double[][] condmat = { { 1., 3. }, { 7., 9. } };
        int rows = 3, cols = 4;
        int invalidld = 5;
        int raggedr = 0;
        int raggedc = 4;
        int validld = 3;
        int nonconformld = 4;
        int ib = 1, ie = 2, jb = 1, je = 3;
        int[] rowindexset = { 1, 2 };
        int[] badrowindexset = { 1, 3 };
        int[] columnindexset = { 1, 2, 3 };
        int[] badcolumnindexset = { 1, 2, 4 };
        double columnsummax = 33.;
        double rowsummax = 30.;
        double sumofdiagonals = 15;
        double sumofsquares = 650;
        print(""\nTesting constructors and constructor-like methods...\n"");
        try {
            A = new Matrix(columnwise, invalidld);
            errorCount = try_failure(errorCount, ""Catch invalid length in packed constructor... "", ""exception not thrown for invalid input"");
        } catch (IllegalArgumentException e) {
            try_success(""Catch invalid length in packed constructor... "", e.getMessage());
        }
        try {
            A = new Matrix(rvals);
            tmp = A.get(raggedr, raggedc);
        } catch (IllegalArgumentException e) {
            try_success(""Catch ragged input to default constructor... "", e.getMessage());
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""Catch ragged input to constructor... "", ""exception not thrown in construction...ArrayIndexOutOfBoundsException thrown later"");
        }
        try {
            A = Matrix.constructWithCopy(rvals);
            tmp = A.get(raggedr, raggedc);
        } catch (IllegalArgumentException e) {
            try_success(""Catch ragged input to constructWithCopy... "", e.getMessage());
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""Catch ragged input to constructWithCopy... "", ""exception not thrown in construction...ArrayIndexOutOfBoundsException thrown later"");
        }
        A = new Matrix(columnwise, validld);
        B = new Matrix(avals);
        tmp = B.get(0, 0);
        avals[0][0] = 0.0;
        C = B.minus(A);
        avals[0][0] = tmp;
        B = Matrix.constructWithCopy(avals);
        tmp = B.get(0, 0);
        avals[0][0] = 0.0;
        if ((tmp - B.get(0, 0)) != 0.0) {
            errorCount = try_failure(errorCount, ""constructWithCopy... "", ""copy not effected... data visible outside"");
        } else {
            try_success(""constructWithCopy... "", """");
        }
        avals[0][0] = columnwise[0];
        I = new Matrix(ivals);
        try {
            check(I, Matrix.identity(3, 4));
            try_success(""identity... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""identity... "", ""identity Matrix not successfully created"");
        }
        print(""\nTesting access methods...\n"");
        B = new Matrix(avals);
        if (B.getRowDimension() != rows) {
            errorCount = try_failure(errorCount, ""getRowDimension... "", """");
        } else {
            try_success(""getRowDimension... "", """");
        }
        if (B.getColumnDimension() != cols) {
            errorCount = try_failure(errorCount, ""getColumnDimension... "", """");
        } else {
            try_success(""getColumnDimension... "", """");
        }
        B = new Matrix(avals);
        double[][] barray = B.getArray();
        if (barray != avals) {
            errorCount = try_failure(errorCount, ""getArray... "", """");
        } else {
            try_success(""getArray... "", """");
        }
        barray = B.getArrayCopy();
        if (barray == avals) {
            errorCount = try_failure(errorCount, ""getArrayCopy... "", ""data not (deep) copied"");
        }
        try {
            check(barray, avals);
            try_success(""getArrayCopy... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""getArrayCopy... "", ""data not successfully (deep) copied"");
        }
        double[] bpacked = B.getColumnPackedCopy();
        try {
            check(bpacked, columnwise);
            try_success(""getColumnPackedCopy... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""getColumnPackedCopy... "", ""data not successfully (deep) copied by columns"");
        }
        bpacked = B.getRowPackedCopy();
        try {
            check(bpacked, rowwise);
            try_success(""getRowPackedCopy... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""getRowPackedCopy... "", ""data not successfully (deep) copied by rows"");
        }
        try {
            tmp = B.get(B.getRowDimension(), B.getColumnDimension() - 1);
            errorCount = try_failure(errorCount, ""get(int,int)... "", ""OutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                tmp = B.get(B.getRowDimension() - 1, B.getColumnDimension());
                errorCount = try_failure(errorCount, ""get(int,int)... "", ""OutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""get(int,int)... OutofBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""get(int,int)... "", ""OutOfBoundsException expected but not thrown"");
        }
        try {
            if (B.get(B.getRowDimension() - 1, B.getColumnDimension() - 1) != avals[B.getRowDimension() - 1][B.getColumnDimension() - 1]) {
                errorCount = try_failure(errorCount, ""get(int,int)... "", ""Matrix entry (i,j) not successfully retreived"");
            } else {
                try_success(""get(int,int)... "", """");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""get(int,int)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        SUB = new Matrix(subavals);
        try {
            M = B.getMatrix(ib, ie + B.getRowDimension() + 1, jb, je);
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                M = B.getMatrix(ib, ie, jb, je + B.getColumnDimension() + 1);
                errorCount = try_failure(errorCount, ""getMatrix(int,int,int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""getMatrix(int,int,int,int)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            M = B.getMatrix(ib, ie, jb, je);
            try {
                check(SUB, M);
                try_success(""getMatrix(int,int,int,int)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""getMatrix(int,int,int,int)... "", ""submatrix not successfully retreived"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int,int)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            M = B.getMatrix(ib, ie, badcolumnindexset);
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                M = B.getMatrix(ib, ie + B.getRowDimension() + 1, columnindexset);
                errorCount = try_failure(errorCount, ""getMatrix(int,int,int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""getMatrix(int,int,int[])... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            M = B.getMatrix(ib, ie, columnindexset);
            try {
                check(SUB, M);
                try_success(""getMatrix(int,int,int[])... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""getMatrix(int,int,int[])... "", ""submatrix not successfully retreived"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""getMatrix(int,int,int[])... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            M = B.getMatrix(badrowindexset, jb, je);
            errorCount = try_failure(errorCount, ""getMatrix(int[],int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                M = B.getMatrix(rowindexset, jb, je + B.getColumnDimension() + 1);
                errorCount = try_failure(errorCount, ""getMatrix(int[],int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""getMatrix(int[],int,int)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""getMatrix(int[],int,int)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            M = B.getMatrix(rowindexset, jb, je);
            try {
                check(SUB, M);
                try_success(""getMatrix(int[],int,int)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""getMatrix(int[],int,int)... "", ""submatrix not successfully retreived"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""getMatrix(int[],int,int)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            M = B.getMatrix(badrowindexset, columnindexset);
            errorCount = try_failure(errorCount, ""getMatrix(int[],int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                M = B.getMatrix(rowindexset, badcolumnindexset);
                errorCount = try_failure(errorCount, ""getMatrix(int[],int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""getMatrix(int[],int[])... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""getMatrix(int[],int[])... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            M = B.getMatrix(rowindexset, columnindexset);
            try {
                check(SUB, M);
                try_success(""getMatrix(int[],int[])... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""getMatrix(int[],int[])... "", ""submatrix not successfully retreived"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            errorCount = try_failure(errorCount, ""getMatrix(int[],int[])... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            B.set(B.getRowDimension(), B.getColumnDimension() - 1, 0.);
            errorCount = try_failure(errorCount, ""set(int,int,double)... "", ""OutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                B.set(B.getRowDimension() - 1, B.getColumnDimension(), 0.);
                errorCount = try_failure(errorCount, ""set(int,int,double)... "", ""OutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""set(int,int,double)... OutofBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""set(int,int,double)... "", ""OutOfBoundsException expected but not thrown"");
        }
        try {
            B.set(ib, jb, 0.);
            tmp = B.get(ib, jb);
            try {
                check(tmp, 0.);
                try_success(""set(int,int,double)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""set(int,int,double)... "", ""Matrix element not successfully set"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
            errorCount = try_failure(errorCount, ""set(int,int,double)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        M = new Matrix(2, 3, 0.);
        try {
            B.setMatrix(ib, ie + B.getRowDimension() + 1, jb, je, M);
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                B.setMatrix(ib, ie, jb, je + B.getColumnDimension() + 1, M);
                errorCount = try_failure(errorCount, ""setMatrix(int,int,int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""setMatrix(int,int,int,int,Matrix)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            B.setMatrix(ib, ie, jb, je, M);
            try {
                check(M.minus(B.getMatrix(ib, ie, jb, je)), M);
                try_success(""setMatrix(int,int,int,int,Matrix)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""setMatrix(int,int,int,int,Matrix)... "", ""submatrix not successfully set"");
            }
            B.setMatrix(ib, ie, jb, je, SUB);
        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int,int,Matrix)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            B.setMatrix(ib, ie + B.getRowDimension() + 1, columnindexset, M);
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                B.setMatrix(ib, ie, badcolumnindexset, M);
                errorCount = try_failure(errorCount, ""setMatrix(int,int,int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""setMatrix(int,int,int[],Matrix)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            B.setMatrix(ib, ie, columnindexset, M);
            try {
                check(M.minus(B.getMatrix(ib, ie, columnindexset)), M);
                try_success(""setMatrix(int,int,int[],Matrix)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""setMatrix(int,int,int[],Matrix)... "", ""submatrix not successfully set"");
            }
            B.setMatrix(ib, ie, jb, je, SUB);
        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int,int,int[],Matrix)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            B.setMatrix(rowindexset, jb, je + B.getColumnDimension() + 1, M);
            errorCount = try_failure(errorCount, ""setMatrix(int[],int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                B.setMatrix(badrowindexset, jb, je, M);
                errorCount = try_failure(errorCount, ""setMatrix(int[],int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""setMatrix(int[],int,int,Matrix)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int[],int,int,Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            B.setMatrix(rowindexset, jb, je, M);
            try {
                check(M.minus(B.getMatrix(rowindexset, jb, je)), M);
                try_success(""setMatrix(int[],int,int,Matrix)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""setMatrix(int[],int,int,Matrix)... "", ""submatrix not successfully set"");
            }
            B.setMatrix(ib, ie, jb, je, SUB);
        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int[],int,int,Matrix)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        try {
            B.setMatrix(rowindexset, badcolumnindexset, M);
            errorCount = try_failure(errorCount, ""setMatrix(int[],int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            try {
                B.setMatrix(badrowindexset, columnindexset, M);
                errorCount = try_failure(errorCount, ""setMatrix(int[],int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
            } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
                try_success(""setMatrix(int[],int[],Matrix)... ArrayIndexOutOfBoundsException... "", """");
            }
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int[],int[],Matrix)... "", ""ArrayIndexOutOfBoundsException expected but not thrown"");
        }
        try {
            B.setMatrix(rowindexset, columnindexset, M);
            try {
                check(M.minus(B.getMatrix(rowindexset, columnindexset)), M);
                try_success(""setMatrix(int[],int[],Matrix)... "", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""setMatrix(int[],int[],Matrix)... "", ""submatrix not successfully set"");
            }
        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {
            errorCount = try_failure(errorCount, ""setMatrix(int[],int[],Matrix)... "", ""Unexpected ArrayIndexOutOfBoundsException"");
        }
        print(""\nTesting array-like methods...\n"");
        S = new Matrix(columnwise, nonconformld);
        R = Matrix.random(A.getRowDimension(), A.getColumnDimension());
        A = R;
        try {
            S = A.minus(S);
            errorCount = try_failure(errorCount, ""minus conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""minus conformance check... "", """");
        }
        if (A.minus(R).norm1() != 0.) {
            errorCount = try_failure(errorCount, ""minus... "", ""(difference of identical Matrices is nonzero,\nSubsequent use of minus should be suspect)"");
        } else {
            try_success(""minus... "", """");
        }
        A = R.copy();
        A.minusEquals(R);
        Z = new Matrix(A.getRowDimension(), A.getColumnDimension());
        try {
            A.minusEquals(S);
            errorCount = try_failure(errorCount, ""minusEquals conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""minusEquals conformance check... "", """");
        }
        if (A.minus(Z).norm1() != 0.) {
            errorCount = try_failure(errorCount, ""minusEquals... "", ""(difference of identical Matrices is nonzero,\nSubsequent use of minus should be suspect)"");
        } else {
            try_success(""minusEquals... "", """");
        }
        A = R.copy();
        B = Matrix.random(A.getRowDimension(), A.getColumnDimension());
        C = A.minus(B);
        try {
            S = A.plus(S);
            errorCount = try_failure(errorCount, ""plus conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""plus conformance check... "", """");
        }
        try {
            check(C.plus(B), A);
            try_success(""plus... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""plus... "", ""(C = A - B, but C + B != A)"");
        }
        C = A.minus(B);
        C.plusEquals(B);
        try {
            A.plusEquals(S);
            errorCount = try_failure(errorCount, ""plusEquals conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""plusEquals conformance check... "", """");
        }
        try {
            check(C, A);
            try_success(""plusEquals... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""plusEquals... "", ""(C = A - B, but C = C + B != A)"");
        }
        A = R.uminus();
        try {
            check(A.plus(R), Z);
            try_success(""uminus... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""uminus... "", ""(-A + A != zeros)"");
        }
        A = R.copy();
        O = new Matrix(A.getRowDimension(), A.getColumnDimension(), 1.0);
        C = A.arrayLeftDivide(R);
        try {
            S = A.arrayLeftDivide(S);
            errorCount = try_failure(errorCount, ""arrayLeftDivide conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayLeftDivide conformance check... "", """");
        }
        try {
            check(C, O);
            try_success(""arrayLeftDivide... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayLeftDivide... "", ""(M.\\M != ones)"");
        }
        try {
            A.arrayLeftDivideEquals(S);
            errorCount = try_failure(errorCount, ""arrayLeftDivideEquals conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayLeftDivideEquals conformance check... "", """");
        }
        A.arrayLeftDivideEquals(R);
        try {
            check(A, O);
            try_success(""arrayLeftDivideEquals... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayLeftDivideEquals... "", ""(M.\\M != ones)"");
        }
        A = R.copy();
        try {
            A.arrayRightDivide(S);
            errorCount = try_failure(errorCount, ""arrayRightDivide conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayRightDivide conformance check... "", """");
        }
        C = A.arrayRightDivide(R);
        try {
            check(C, O);
            try_success(""arrayRightDivide... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayRightDivide... "", ""(M./M != ones)"");
        }
        try {
            A.arrayRightDivideEquals(S);
            errorCount = try_failure(errorCount, ""arrayRightDivideEquals conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayRightDivideEquals conformance check... "", """");
        }
        A.arrayRightDivideEquals(R);
        try {
            check(A, O);
            try_success(""arrayRightDivideEquals... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayRightDivideEquals... "", ""(M./M != ones)"");
        }
        A = R.copy();
        B = Matrix.random(A.getRowDimension(), A.getColumnDimension());
        try {
            S = A.arrayTimes(S);
            errorCount = try_failure(errorCount, ""arrayTimes conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayTimes conformance check... "", """");
        }
        C = A.arrayTimes(B);
        try {
            check(C.arrayRightDivideEquals(B), A);
            try_success(""arrayTimes... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayTimes... "", ""(A = R, C = A.*B, but C./B != A)"");
        }
        try {
            A.arrayTimesEquals(S);
            errorCount = try_failure(errorCount, ""arrayTimesEquals conformance check... "", ""nonconformance not raised"");
        } catch (IllegalArgumentException e) {
            try_success(""arrayTimesEquals conformance check... "", """");
        }
        A.arrayTimesEquals(B);
        try {
            check(A.arrayRightDivideEquals(B), R);
            try_success(""arrayTimesEquals... "", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""arrayTimesEquals... "", ""(A = R, A = A.*B, but A./B != R)"");
        }
        print(""\nTesting I/O methods...\n"");
        try {
            DecimalFormat fmt = new DecimalFormat(""0.0000E00"");
            fmt.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));
            PrintWriter FILE = new PrintWriter(new FileOutputStream(""JamaTestMatrix.out""));
            A.print(FILE, fmt, 10);
            FILE.close();
            R = Matrix.read(new BufferedReader(new FileReader(""JamaTestMatrix.out"")));
            if (A.minus(R).norm1() < .001) {
                try_success(""print()/read()..."", """");
            } else {
                errorCount = try_failure(errorCount, ""print()/read()..."", ""Matrix read from file does not match Matrix printed to file"");
            }
        } catch (java.io.IOException ioe) {
            warningCount = try_warning(warningCount, ""print()/read()..."", ""unexpected I/O error, unable to run print/read test;  check write permission in current directory and retry"");
        } catch (Exception e) {
            try {
                e.printStackTrace(System.out);
                warningCount = try_warning(warningCount, ""print()/read()..."", ""Formatting error... will try JDK1.1 reformulation..."");
                DecimalFormat fmt = new DecimalFormat(""0.0000"");
                PrintWriter FILE = new PrintWriter(new FileOutputStream(""JamaTestMatrix.out""));
                A.print(FILE, fmt, 10);
                FILE.close();
                R = Matrix.read(new BufferedReader(new FileReader(""JamaTestMatrix.out"")));
                if (A.minus(R).norm1() < .001) {
                    try_success(""print()/read()..."", """");
                } else {
                    errorCount = try_failure(errorCount, ""print()/read() (2nd attempt) ..."", ""Matrix read from file does not match Matrix printed to file"");
                }
            } catch (java.io.IOException ioe) {
                warningCount = try_warning(warningCount, ""print()/read()..."", ""unexpected I/O error, unable to run print/read test;  check write permission in current directory and retry"");
            }
        }
        R = Matrix.random(A.getRowDimension(), A.getColumnDimension());
        String tmpname = ""TMPMATRIX.serial"";
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(tmpname));
            out.writeObject(R);
            ObjectInputStream sin = new ObjectInputStream(new FileInputStream(tmpname));
            A = (Matrix) sin.readObject();
            try {
                check(A, R);
                try_success(""writeObject(Matrix)/readObject(Matrix)..."", """");
            } catch (java.lang.RuntimeException e) {
                errorCount = try_failure(errorCount, ""writeObject(Matrix)/readObject(Matrix)..."", ""Matrix not serialized correctly"");
            }
        } catch (java.io.IOException ioe) {
            warningCount = try_warning(warningCount, ""writeObject()/readObject()..."", ""unexpected I/O error, unable to run serialization test;  check write permission in current directory and retry"");
        } catch (Exception e) {
            errorCount = try_failure(errorCount, ""writeObject(Matrix)/readObject(Matrix)..."", ""unexpected error in serialization test"");
        }
        print(""\nTesting linear algebra methods...\n"");
        A = new Matrix(columnwise, 3);
        T = new Matrix(tvals);
        T = A.transpose();
        try {
            check(A.transpose(), T);
            try_success(""transpose..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""transpose()..."", ""transpose unsuccessful"");
        }
        A.transpose();
        try {
            check(A.norm1(), columnsummax);
            try_success(""norm1..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""norm1()..."", ""incorrect norm calculation"");
        }
        try {
            check(A.normInf(), rowsummax);
            try_success(""normInf()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""normInf()..."", ""incorrect norm calculation"");
        }
        try {
            check(A.normF(), Math.sqrt(sumofsquares));
            try_success(""normF..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""normF()..."", ""incorrect norm calculation"");
        }
        try {
            check(A.trace(), sumofdiagonals);
            try_success(""trace()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""trace()..."", ""incorrect trace calculation"");
        }
        try {
            check(A.getMatrix(0, A.getRowDimension() - 1, 0, A.getRowDimension() - 1).det(), 0.);
            try_success(""det()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""det()..."", ""incorrect determinant calculation"");
        }
        SQ = new Matrix(square);
        try {
            check(A.times(A.transpose()), SQ);
            try_success(""times(Matrix)..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""times(Matrix)..."", ""incorrect Matrix-Matrix product calculation"");
        }
        try {
            check(A.times(0.), Z);
            try_success(""times(double)..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""times(double)..."", ""incorrect Matrix-scalar product calculation"");
        }
        A = new Matrix(columnwise, 4);
        QRDecomposition QR = A.qr();
        R = QR.getR();
        try {
            check(A, QR.getQ().times(R));
            try_success(""QRDecomposition..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""QRDecomposition..."", ""incorrect QR decomposition calculation"");
        }
        SingularValueDecomposition SVD = A.svd();
        try {
            check(A, SVD.getU().times(SVD.getS().times(SVD.getV().transpose())));
            try_success(""SingularValueDecomposition..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""SingularValueDecomposition..."", ""incorrect singular value decomposition calculation"");
        }
        DEF = new Matrix(rankdef);
        try {
            check(DEF.rank(), Math.min(DEF.getRowDimension(), DEF.getColumnDimension()) - 1);
            try_success(""rank()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""rank()..."", ""incorrect rank calculation"");
        }
        B = new Matrix(condmat);
        SVD = B.svd();
        double[] singularvalues = SVD.getSingularValues();
        try {
            check(B.cond(), singularvalues[0] / singularvalues[Math.min(B.getRowDimension(), B.getColumnDimension()) - 1]);
            try_success(""cond()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""cond()..."", ""incorrect condition number calculation"");
        }
        int n = A.getColumnDimension();
        A = A.getMatrix(0, n - 1, 0, n - 1);
        A.set(0, 0, 0.);
        LUDecomposition LU = A.lu();
        try {
            check(A.getMatrix(LU.getPivot(), 0, n - 1), LU.getL().times(LU.getU()));
            try_success(""LUDecomposition..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""LUDecomposition..."", ""incorrect LU decomposition calculation"");
        }
        X = A.inverse();
        try {
            check(A.times(X), Matrix.identity(3, 3));
            try_success(""inverse()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""inverse()..."", ""incorrect inverse calculation"");
        }
        O = new Matrix(SUB.getRowDimension(), 1, 1.0);
        SOL = new Matrix(sqSolution);
        SQ = SUB.getMatrix(0, SUB.getRowDimension() - 1, 0, SUB.getRowDimension() - 1);
        try {
            check(SQ.solve(SOL), O);
            try_success(""solve()..."", """");
        } catch (java.lang.IllegalArgumentException e1) {
            errorCount = try_failure(errorCount, ""solve()..."", e1.getMessage());
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""solve()..."", e.getMessage());
        }
        A = new Matrix(pvals);
        CholeskyDecomposition Chol = A.chol();
        Matrix L = Chol.getL();
        try {
            check(A, L.times(L.transpose()));
            try_success(""CholeskyDecomposition..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""CholeskyDecomposition..."", ""incorrect Cholesky decomposition calculation"");
        }
        X = Chol.solve(Matrix.identity(3, 3));
        try {
            check(A.times(X), Matrix.identity(3, 3));
            try_success(""CholeskyDecomposition solve()..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""CholeskyDecomposition solve()..."", ""incorrect Choleskydecomposition solve calculation"");
        }
        EigenvalueDecomposition Eig = A.eig();
        Matrix D = Eig.getD();
        Matrix V = Eig.getV();
        try {
            check(A.times(V), V.times(D));
            try_success(""EigenvalueDecomposition (symmetric)..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""EigenvalueDecomposition (symmetric)..."", ""incorrect symmetric Eigenvalue decomposition calculation"");
        }
        A = new Matrix(evals);
        Eig = A.eig();
        D = Eig.getD();
        V = Eig.getV();
        try {
            check(A.times(V), V.times(D));
            try_success(""EigenvalueDecomposition (nonsymmetric)..."", """");
        } catch (java.lang.RuntimeException e) {
            errorCount = try_failure(errorCount, ""EigenvalueDecomposition (nonsymmetric)..."", ""incorrect nonsymmetric Eigenvalue decomposition calculation"");
        }
        print(""\nTestMatrix completed.\n"");
        print(""Total errors reported: "" + Integer.toString(errorCount) + ""\n"");
        print(""Total warnings reported: "" + Integer.toString(warningCount) + ""\n"");
    }
","    public static void copyFileByNIO(File in, File out) throws IOException {
        FileChannel sourceChannel = new FileInputStream(in).getChannel();
        FileChannel destinationChannel = new FileOutputStream(out).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
"
"    public static int zipFile(File file_input, File dir_output) {
        File zip_output = new File(dir_output, file_input.getName() + "".zip"");
        ZipOutputStream zip_out_stream;
        try {
            FileOutputStream out = new FileOutputStream(zip_output);
            zip_out_stream = new ZipOutputStream(new BufferedOutputStream(out));
        } catch (IOException e) {
            return STATUS_OUT_FAIL;
        }
        byte[] input_buffer = new byte[BUF_SIZE];
        int len = 0;
        try {
            ZipEntry zip_entry = new ZipEntry(file_input.getName());
            zip_out_stream.putNextEntry(zip_entry);
            FileInputStream in = new FileInputStream(file_input);
            BufferedInputStream source = new BufferedInputStream(in, BUF_SIZE);
            while ((len = source.read(input_buffer, 0, BUF_SIZE)) != -1) zip_out_stream.write(input_buffer, 0, len);
            in.close();
        } catch (IOException e) {
            return STATUS_ZIP_FAIL;
        }
        try {
            zip_out_stream.close();
        } catch (IOException e) {
        }
        return STATUS_OK;
    }
","                    public final void deliver(final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {
                        System.out.println(""FROM: "" + from);
                        System.out.println(""TO: "" + recipient);
                        final File tmpDir = new File(System.getProperty(""java.io.tmpdir""));
                        final File file = new File(tmpDir, recipient);
                        final FileWriter fw = new FileWriter(file);
                        try {
                            IOUtils.copy(data, fw);
                        } finally {
                            fw.close();
                        }
                    }
"
